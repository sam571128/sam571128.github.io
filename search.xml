<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces Round &amp;#35;673 (Div.2)</title>
    <url>/2020/09/29/Codeforces-Round-673-Div-2/</url>
    <content><![CDATA[<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這場只答對三題pA, pB, pC<br>所以掉分了(´Д` )<br>1793 -&gt; 1781<br><a id="more"></a></p>
<h2 id="Problem-A-Copy-paste"><a href="#Problem-A-Copy-paste" class="headerlink" title="Problem A - Copy-paste"></a>Problem A - Copy-paste</h2><p>給予一個 $n$ 項的陣列以及一個 $k$ 值</p>
<p>你能挑選  $1\leq i,j \leq n$<br>並讓 $a_j = a_j + a_i$</p>
<p>問最多能做幾次</p>
<p>這題我一看到是直接砸priority_queue<br>不過其實這題很簡單的做法是<br>選取 $min(a_0,a_1,…,a_n)$ 的值<br>並用該值去增加其他項的數值</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,tmp;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		pq.push(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(pq.top()&lt;=k)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = pq.top(); pq.pop();</span><br><span class="line">		<span class="keyword">int</span> b = pq.top(); pq.pop();</span><br><span class="line">		<span class="keyword">if</span>(a+b &lt;= k)&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pq.push(a+b);</span><br><span class="line">		pq.push(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-B-Two-Arrays"><a href="#Problem-B-Two-Arrays" class="headerlink" title="Problem B - Two Arrays"></a>Problem B - Two Arrays</h2><p>題意是說<br>給予一個 $n$ 項的陣列與一個 $T$ 值<br>你可以將整個陣列塗兩種顏色<br>使得同一個顏色當中 任兩個元素總和為 $T$ 的數量最小化</p>
<p>這題我一開始想錯 砸了兩次WA 不過這題非常簡單<br>首先 我們先掃過每一個元素 $a_i$<br>決定是否將 $a_i$ 塗色<br>若我們尚未塗過 $T-a_i$ 我們就將 $a_i$ 塗色<br>這個題目有一個小陷阱<br>那就是當元素可重複且元素為 $\frac{t}{2}$<br>我們就必須把同個元素塗上不同的顏色<br>否則同元素放在同一顏色當中反而更好</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; c,cnt;</span><br><span class="line">	<span class="keyword">int</span> n,t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> arr[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : arr) <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		cnt[arr[i]]++;</span><br><span class="line">		<span class="keyword">if</span>(!c[t-arr[i]])</span><br><span class="line">			c[arr[i]] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]==t-arr[i]&amp;&amp;cnt[arr[i]]%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; (c[arr[i]]^<span class="number">1</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; c[arr[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cnt[arr[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-C-k-Amazing-Numbers"><a href="#Problem-C-k-Amazing-Numbers" class="headerlink" title="Problem C - k-Amazing Numbers"></a>Problem C - k-Amazing Numbers</h2><p>這題是說給予一個 $n$ 項的陣列<br>問在每一個長度為 $k$ 的子陣列當中 都有出現的最小元素<br>並依序從 $k=1 \sim k=n$ 分別輸出最小元素</p>
<p>這題我的做法是紀錄 $1 \sim n$ 相隔最久都沒有出現重複的長度<br>之後就能用這個去得到答案了<br>由於出現在每個長度為 $k$ 的子陣列的元素 一定出現在長度為 $k+1$的子陣列 我們也需要用 $k$的元素來更新 $k+1$的元素</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> g = <span class="number">0</span>, mi = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> arr[n+<span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span> ans[n+<span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		mi = min(mi,tmp);</span><br><span class="line">		ans[tmp] = max(ans[tmp],(arr[tmp]+g + (ans[tmp]==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)));</span><br><span class="line">		arr[tmp] = -i;</span><br><span class="line">		g++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pr</span><span class="params">(n+<span class="number">2</span>,<span class="number">1e9</span>+<span class="number">7</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		ans[i] = max(ans[i],arr[i]+g);</span><br><span class="line">		pr[ans[i]] = min(i,pr[ans[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	pr[n] = mi;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		pr[i+<span class="number">1</span>] = min(pr[i+<span class="number">1</span>],pr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pr[i]==<span class="number">1e9</span>+<span class="number">7</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; pr[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-D-Make-Them-Equal"><a href="#Problem-D-Make-Them-Equal" class="headerlink" title="Problem D - Make Them Equal"></a>Problem D - Make Them Equal</h2><p>這題真的要說的話 難度並不高<br><br>不過我一直砸 伴隨而來的是無止盡的WA<br><br><img src="https://i.imgur.com/5QLQW5q.png" alt=""><br>度的 就是如此的可撥(／‵Д′)／~ ╧╧ </p>
<p>這題的題目是說給予一個n項的陣列<br><br>你可以進行操作<br><br>$\Rightarrow$ 選擇三個整數 $i,j,x$<br><br>$\Rightarrow$ 將$a_j = a_j + i\times x$，$a_i = a_i - i \times x$<br><br>問是否能在 $3n$ 次操作內 使得陣列中的所有元素相等</p>
<p>這題其實 $3n$ 是非常寬的一個數字 <br><br>而這題的作法其實非常簡單<br><br>我們可以把題目的操作理解成 $\Rightarrow$ 選擇 $a_i$ 並將 $i$ 的倍數轉移至 $a_j$</p>
<p>我們可以很輕易想到 如果要使得每個元素相等 代表所有元素應變為他們的算術平均數<br><br>因此 當總和不是 $n$ 的倍數時 我們就可以排除這個解</p>
<p>接下來的作法就非常簡單了<br><br>由於我們不容易想應該如何將 $i$ 的倍數轉移<br><br>如果我們可以先將所有的數字先集中到 $a_1$ 之後　<br><br>再由 $a_1$ 去分配給其他元素 這就會是一個非常好的解法了</p>
<p>然而，說來簡單 如何將其他元素都集中到 $a_1$ 呢？</p>
<p>題目有一個條件 $1 \leq a_i \leq 10^5$ <br><br>既然 $a_i$ 一定大於0 我們可以從 $a_2$ 開始分別將數字轉移至 $a_1$</p>
<p>當我們要轉移 $a_i$ 的值到 $a_1$ 時　<br><br>我們會先將 $a_i$ 的值變為 $i$ 的倍數　<br><br>這樣我們就可以直接轉移到 $a_1$ 身上了　</p>
<p>附上程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> arr[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		sum += arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum%n)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sum/=n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt;&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]%(i+<span class="number">1</span>))&#123;</span><br><span class="line">			v.push_back(&#123;<span class="number">1</span>,i+<span class="number">1</span>,i+<span class="number">1</span>-arr[i]%(i+<span class="number">1</span>)&#125;);</span><br><span class="line">			arr[<span class="number">0</span>] -= i+<span class="number">1</span>-arr[i]%(i+<span class="number">1</span>);</span><br><span class="line">			arr[i] += i+<span class="number">1</span>-arr[i]%(i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		v.push_back(&#123;i+<span class="number">1</span>,<span class="number">1</span>,arr[i]/(i+<span class="number">1</span>)&#125;);</span><br><span class="line">		arr[<span class="number">0</span>] += (arr[i]/(i+<span class="number">1</span>))*(i+<span class="number">1</span>);</span><br><span class="line">		arr[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		v.push_back(&#123;<span class="number">1</span>,i+<span class="number">1</span>,sum&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v.size() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : v)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> y : x)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-E-XOR-Inverse"><a href="#Problem-E-XOR-Inverse" class="headerlink" title="Problem E - XOR Inverse"></a>Problem E - XOR Inverse</h2><p>待補</p>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>Math</tag>
        <tag>Greedy</tag>
        <tag>藍牌</tag>
        <tag>摔分</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round &amp;#35;674 (Div.3)</title>
    <url>/2020/10/04/Codeforces-Round-674-Div-3/</url>
    <content><![CDATA[<p>這週一沒有打這場比賽 因為時間實在是沒有辦法打 இдஇ</p>
<p>今天突然想到 就決定來Virtual一下了</p>
<p>打完之後覺得自己真的是太久沒有打 Div.3 了</p>
<p>這種Ad-Hoc的題目都要想很久才會解<br><a id="more"></a></p>
<h2 id="Problem-A-Floor-Number"><a href="#Problem-A-Floor-Number" class="headerlink" title="Problem A - Floor Number"></a>Problem A - Floor Number</h2><p><img src="https://i.imgur.com/11VW40F.png" alt=""><br>還沒看題目 看到範測 直接砸了 $\lceil \frac{n}{x} \rceil$ </p>
<p>然後就WA了 (☍﹏⁰)</p>
<p>看了題目才知道 他是第一樓只能住 $2$ 個人</p>
<p>所以改成 $\lfloor \frac{n}{x} \rfloor+2$ 然後特判 $n \leq 2$ 就過了</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (n&lt;= <span class="number">2</span> ? <span class="number">1</span> : (n<span class="number">-3</span>)/x+<span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-B-Symmetric-Matrix"><a href="#Problem-B-Symmetric-Matrix" class="headerlink" title="Problem B - Symmetric Matrix"></a>Problem B - Symmetric Matrix</h2><p><img src="https://i.imgur.com/iimHPuY.png" alt=""></p>
<p>題目很長 不太想讀</p>
<p>不過意思是他會給 $n$ 個 $2\times2$ 的矩陣無限多個 </p>
<p>問是否能排出 $m \times m$ 對稱對角線的矩陣</p>
<p>這題有兩個條件 </p>
<blockquote>
<p>第一個是 $m$ 要是二的倍數</p>
<p>第二個是至少一個矩陣的右上和左下要相等</p>
</blockquote>
<p>這兩個條件符合就過了</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,c,d;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">		<span class="keyword">if</span>(b==c)&#123;</span><br><span class="line">			ok = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m%<span class="number">2</span>) ok = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (ok ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-C-Increase-And-Copy"><a href="#Problem-C-Increase-And-Copy" class="headerlink" title="Problem C - Increase And Copy"></a>Problem C - Increase And Copy</h2><p><img src="https://i.imgur.com/UQKeq0d.png" alt=""></p>
<p>看著題目想了一下子 一直都沒有想法</p>
<p>不過仔細想過之後會發現 </p>
<p>要達到最好的解一定是先增加之後再一併複製</p>
<p>因此我們只要一直對一開始的 $1$ 去加 $1$</p>
<p>最後再乘以一個數字就好了</p>
<p>我們可以用枚舉的方式達到這一點</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="built_in">sqrt</span>(<span class="number">1e9</span>);i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = (n<span class="number">-1</span>)/(i+<span class="number">1</span>);</span><br><span class="line">		ans = min(ans,tmp+i); </span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-D-Non-zero-Segment"><a href="#Problem-D-Non-zero-Segment" class="headerlink" title="Problem D - Non-zero Segment"></a>Problem D - Non-zero Segment</h2><p><img src="https://i.imgur.com/tXc5H5e.png" alt=""></p>
<p>這題看到題目 就會想到要用前綴和 （使區間和不等於 $0$）</p>
<p>區間和為 $0$ 的狀況就是有兩個前綴和值相等</p>
<p>而我們要加幾次才能讓前綴和兩兩不相等呢</p>
<p>仔細想一下 會發現如果我們每次都加一個非常非常大的值</p>
<p>沒有加到這個值的前綴和一定不會和後面相等</p>
<p>所以我們只要在相等的時候 重置 map 的值就好</p>
<p>然後當前綴和為 $0$ 的時候也要重製 map</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	m[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		now+=tmp;</span><br><span class="line">		<span class="keyword">if</span>(m[now])&#123;</span><br><span class="line">			m.clear();</span><br><span class="line">			ans++;</span><br><span class="line">			now = tmp;	</span><br><span class="line">			m[<span class="number">0</span>]++;		</span><br><span class="line">		&#125;</span><br><span class="line">		m[now]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-E-Rock-Paper-Scissors"><a href="#Problem-E-Rock-Paper-Scissors" class="headerlink" title="Problem E - Rock, Paper, Scissors"></a>Problem E - Rock, Paper, Scissors</h2><p><img src="https://i.imgur.com/JMMDK4H.png" alt=""></p>
<p>這題的話就是兩個人剪刀石頭布</p>
<p>其實想一下很快就解出來了</p>
<p>不知道為什麼會放這種題在pE (*´･д･)?</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> a,b,c,d,e,f;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; min(max(<span class="number">0</span>,a-d-f),e)+min(max(<span class="number">0</span>,b-e-d),f)+min(max(<span class="number">0</span>,c-f-e),d) &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; min(a,e)+min(b,f)+min(c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-F-Number-of-Subsequences"><a href="#Problem-F-Number-of-Subsequences" class="headerlink" title="Problem F - Number of Subsequences"></a>Problem F - Number of Subsequences</h2><p><img src="https://i.imgur.com/bTVNuOJ.png" alt=""></p>
<p>總算不是 Ad-Hoc 題了 前面幾題都是 Ad-Hoc 超痛苦</p>
<p>這題一看到 就知道要使用 dp 來解了</p>
<p>所以就列出轉移式 然後就 AC 了</p>
<p>複雜度: $O(n)$</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="keyword">int</span> dp[n][<span class="number">3</span>] = &#123;&#125;, cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = (dp[i][<span class="number">0</span>] + cnt)%MOD;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">				dp[i][<span class="number">1</span>] = (dp[i][<span class="number">1</span>] + dp[i<span class="number">-1</span>][<span class="number">0</span>])%MOD;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;c&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">				dp[i][<span class="number">2</span>] = (dp[i][<span class="number">2</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>])%MOD;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = (dp[i][<span class="number">0</span>]*<span class="number">3</span> + cnt)%MOD;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">				dp[i][<span class="number">1</span>] = (dp[i][<span class="number">1</span>]*<span class="number">3</span> + dp[i<span class="number">-1</span>][<span class="number">0</span>])%MOD;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">				dp[i][<span class="number">2</span>] = (dp[i][<span class="number">2</span>]*<span class="number">3</span> + dp[i<span class="number">-1</span>][<span class="number">1</span>])%MOD;</span><br><span class="line">			cnt = cnt*<span class="number">3</span>%MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i!=n<span class="number">-1</span>)&#123;</span><br><span class="line">			dp[i+<span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>];</span><br><span class="line">			dp[i+<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>];</span><br><span class="line">			dp[i+<span class="number">1</span>][<span class="number">2</span>] = dp[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[n<span class="number">-1</span>][<span class="number">2</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>藍牌</tag>
        <tag>Ad-Hoc</tag>
        <tag>DP</tag>
        <tag>Virtual</tag>
      </tags>
  </entry>
  <entry>
    <title>凸包 Convex Hull</title>
    <url>/2020/10/05/Convex-Hull/</url>
    <content><![CDATA[<p>今天也是不知道該學什麼 </p>
<p>剛好想到這也是一個我還沒有學過的東西</p>
<p>因此 今天就決定來紀錄一下凸包與動態凸包<br><a id="more"></a></p>
<h2 id="什麼是凸包"><a href="#什麼是凸包" class="headerlink" title="什麼是凸包?"></a>什麼是凸包?</h2><p>先附上維基百科的定義</p>
<p><img src="https://i.imgur.com/tXufUds.png" alt=""></p>
<p>看起來很數學 不過他的定義簡單來說就是一個平面上有很多個點</p>
<p>能夠包住所有點且面積最小的凸多邊形就叫作凸包</p>
<p><img src="https://i.imgur.com/s3Bsgpp.png" alt=""></p>
<h2 id="如何找到凸包？"><a href="#如何找到凸包？" class="headerlink" title="如何找到凸包？"></a>如何找到凸包？</h2><p>要求一個平面上的凸包 比較常見的有兩種作法</p>
<h3 id="一、Andrew’s-Monotone-Chain"><a href="#一、Andrew’s-Monotone-Chain" class="headerlink" title="一、Andrew’s Monotone Chain"></a>一、Andrew’s Monotone Chain</h3><p>這個是利用單調隊列的方式來得到凸包</p>
<p>我們先依照點的<strong>x座標做排序</strong>，再以<strong>y座標做排序</strong></p>
<p>分別求出<strong>下凸包</strong>以及<strong>上凸包</strong></p>
<p>用stack去維護每個點</p>
<p>當向量的外積小於等於零時 就pop<br><img src="https://i.imgur.com/R6VuVuU.gif" alt=""></p>
<p>複雜度: $O(nlogn)$</p>
<h3 id="二、Graham’s-Scan"><a href="#二、Graham’s-Scan" class="headerlink" title="二、Graham’s Scan"></a>二、Graham’s Scan</h3><p>先找到最左下的點($y 座標最小的最左邊的點）</p>
<p>並用其他點對這個點做極角排序</p>
<p>同樣用一個stack來維護凸包上的點</p>
<p><img src="https://i.imgur.com/5rtTjsI.gif" alt=""></p>
<p>複雜度： $O(nlogn)$</p>
<h3 id="三、實作凸包演算法"><a href="#三、實作凸包演算法" class="headerlink" title="三、實作凸包演算法"></a>三、實作凸包演算法</h3><p>我們用Andrew’s Monotone Chain來找凸包 </p>
<p>至於Graham’s Scan 大家可以自己去找相關資料</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">pair</span>&lt;T,T&gt; <span class="keyword">operator</span> - (<span class="built_in">pair</span>&lt;T,T&gt; a, <span class="built_in">pair</span>&lt;T,T&gt; b)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make_pair</span>(a.first-b.first,a.second-b.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">cross</span><span class="params">(<span class="built_in">pair</span>&lt;T,T&gt; a, <span class="built_in">pair</span>&lt;T,T&gt; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.first*b.second-a.second*b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">vector&lt;pair&lt;T,T&gt;&gt; getCH(vector&lt;pair&lt;T,T&gt;&gt; v)&#123;</span><br><span class="line">	<span class="keyword">int</span> n = v.size();</span><br><span class="line">	sort(v.begin(),v.end());</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;T,T&gt;&gt; hull;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> t = hull.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : v)&#123;</span><br><span class="line">			<span class="keyword">while</span>(hull.size()-t&gt;=<span class="number">2</span>&amp;&amp;cross(hull[hull.size()<span class="number">-1</span>]-hull[hull.size()<span class="number">-2</span>],x-hull[hull.size()<span class="number">-2</span>])&lt;=<span class="number">0</span>)</span><br><span class="line">				hull.pop_back();</span><br><span class="line">			hull.push_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		hull.pop_back();</span><br><span class="line">		reverse(v.begin(), v.end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="凸包-例題"><a href="#凸包-例題" class="headerlink" title="凸包 例題"></a>凸包 例題</h2><h3 id="一、TIOJ-1178-Convex-Hull"><a href="#一、TIOJ-1178-Convex-Hull" class="headerlink" title="一、TIOJ 1178 - Convex Hull"></a>一、TIOJ 1178 - Convex Hull</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1178">題目連結</a></p>
<p>這題就是凸包的裸題 求出凸包之後 輸出有幾個頂點就好</p>
<h3 id="二、Zerojudge-a871-Museum-Area"><a href="#二、Zerojudge-a871-Museum-Area" class="headerlink" title="二、Zerojudge a871 - Museum Area"></a>二、Zerojudge a871 - Museum Area</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=a871">題目連結</a></p>
<p>這題就是求凸包面積 要找凸包的面積就用外積和/2 （要記得逆時針）</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//這裡省略求凸包的程式碼</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;&gt; v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="keyword">double</span> x,y;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			v.emplace_back(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;&gt; CH = getCH(v);</span><br><span class="line">		<span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">double</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">			ans += cross(CH[i<span class="number">-1</span>]-CH[<span class="number">0</span>],CH[i]-CH[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; ans/<span class="number">2.0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="三、Zerojudge-d546-減多邊形"><a href="#三、Zerojudge-d546-減多邊形" class="headerlink" title="三、Zerojudge d546 - 減多邊形"></a>三、Zerojudge d546 - 減多邊形</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d546">題目連結</a></p>
<p>這題是98年的北市賽題目</p>
<p>因為一開始給的點就是逆時針的 我們用凸包面積減去原多邊形面積再除以 $a$ 的 $ceil$ 就是答案了</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n,a;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">double</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		v.emplace_back(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> tmp = <span class="number">0</span>; <span class="comment">//原多邊形面積</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		tmp += cross(v[i<span class="number">-1</span>]-v[<span class="number">0</span>],v[i]-v[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	tmp/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">double</span> tmp2 = <span class="number">0</span>; <span class="comment">//凸包面積</span></span><br><span class="line">	v = getCH(v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">		tmp2 += cross(v[i<span class="number">-1</span>]-v[<span class="number">0</span>],v[i]-v[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	tmp2/=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)<span class="built_in">ceil</span>((tmp2-tmp)/a) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、TIOJ-1280-領土-Territory"><a href="#四、TIOJ-1280-領土-Territory" class="headerlink" title="四、TIOJ 1280 - 領土 (Territory)"></a>四、TIOJ 1280 - 領土 (Territory)</h3><p><a href="https://tioj.ck.tp.edu.tw/problems/1280">題目連結</a></p>
<p>這題是103年的北市賽題目</p>
<p>也是直接求凸包面積</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="keyword">operator</span> - (<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;a.first-b.first,a.second-b.second&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cross</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.first*b.second-a.second*b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt; getCH(vector&lt;pair&lt;int,int&gt;&gt; v)&#123;</span><br><span class="line">	<span class="keyword">int</span> n = v.size();</span><br><span class="line">	sort(v.begin(),v.end());</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> t = ans.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : v)&#123;</span><br><span class="line">			<span class="keyword">while</span>(ans.size()-t &gt;= <span class="number">2</span> &amp;&amp; cross(ans.back()-ans[ans.size()<span class="number">-2</span>],x-ans[ans.size()<span class="number">-2</span>])&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">				ans.pop_back();</span><br><span class="line">			&#125;</span><br><span class="line">			ans.push_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		ans.pop_back();</span><br><span class="line">		reverse(v.begin(),v.end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		v.emplace_back(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	v = getCH(v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; v.size();i++)&#123;</span><br><span class="line">		ans += cross(v[i<span class="number">-1</span>]-v[<span class="number">0</span>],v[i]-v[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (ans+<span class="number">1</span>)/<span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="動態凸包"><a href="#動態凸包" class="headerlink" title="動態凸包"></a>動態凸包</h2><p>我們可以用一個例題來理解動態凸包是什麼<br><a href="https://codeforces.com/problemset/problem/70/D">Codeforces 70D</a></p>
<blockquote>
<p>有 $q$ 個操作與詢問</p>
<p>每次操作在平面上加入一個點 $(x,y)$</p>
<p>每次詢問一個點 $(x,y)$ 是否在凸包內</p>
</blockquote>
<p>這題想了一下之後 你可能會覺得我們要怎麼去維護新的凸包呢？</p>
<p>假如我們用的是Andrew’s Monotone Chain</p>
<p>我們所有點都是依 $x,y$ 座標進行排序的</p>
<p>或者我們用的是極角排序的 Graham’s Scan</p>
<p>有一種資料結構能夠幫助我們做到這一點</p>
<p>那就是 std::set !</p>
<p>後續代補</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>計算幾何</tag>
        <tag>教學</tag>
      </tags>
  </entry>
  <entry>
    <title>Grakn Forces 2020 (Codeforces 1408)</title>
    <url>/2020/10/01/Grakn-Forces/</url>
    <content><![CDATA[<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>再度掉分｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡  <br><br>從1781 -&gt; 1760 我怎麼那麼爛R <br><br>這場因為pB一開始題目出問題 卡了一陣子（也不算一陣子 大概是快一小時吧(／‵Д′)／~ ╧╧) <br><br>最後只解出 pA, pB, pC <br><br>連結: <a href="https://codeforces.com/contest/1408">https://codeforces.com/contest/1408</a><br><a id="more"></a></p>
<h2 id="Problem-A-Circle-Coloring"><a href="#Problem-A-Circle-Coloring" class="headerlink" title="Problem A - Circle Coloring"></a>Problem A - Circle Coloring</h2><p><img src="https://i.imgur.com/yVgFg3M.png" alt=""></p>
<p>這題一開始因為 <script type="math/tex">p_i \neq p_{(i \mod n)+1}</script> 這敘述想了一下子 <br><br>不過理解後 題目下一段就直接告訴你那行的意思了（直接給不就好了╰(〒皿〒)╯） </p>
<p>反正就是給你三個陣列 從這三個陣列中挑一個數字組成新的陣列 <br><br>然後新的陣列相鄰兩元素不相等（包括最後一個和第一個）</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) <span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">	<span class="keyword">int</span> ans[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">				ans[i] = arr[j][i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i!=n<span class="number">-1</span>&amp;&amp;arr[j][i]!=ans[i<span class="number">-1</span>])&#123;</span><br><span class="line">				ans[i] = arr[j][i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==n<span class="number">-1</span>&amp;&amp;arr[j][i]!=ans[<span class="number">0</span>]&amp;&amp;arr[j][i]!=ans[i<span class="number">-1</span>])&#123;</span><br><span class="line">				ans[i] = arr[j][i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-B-Arrays-Sum"><a href="#Problem-B-Arrays-Sum" class="headerlink" title="Problem B - Arrays Sum"></a>Problem B - Arrays Sum</h2><p><img src="https://i.imgur.com/ygdxRTb.png" alt=""></p>
<p>這題其實一開始讀到題目的時候就想到正解了 <br><br>覺得答案應該是 $\lceil \frac{不同數字的數量-1}{k-1} \rceil$ <br><br>然後特判 $k=1$ 的情況</p>
<p>不過測資出了問題<br><img src="https://i.imgur.com/GRKV1JF.png" alt=""> </p>
<p>一開始看到測資時 想了一下子 <br><br>明明用我的想法第四和第五個測資答案就是2 2 <br><br>結果不是 把$\lceil \frac{不同數字的數量-1}{k-1} \rceil$ 的結論丟掉之後就卡住了 <br><br>直到<br><img src="https://i.imgur.com/JfHGVLA.png" alt=""> <br><br>然後我又想了好久 那第五個測資呢٩(ŏ﹏ŏ、)۶ </p>
<p>後來終於</p>
<p><img src="https://i.imgur.com/EhZQ4eV.png" alt=""></p>
<p>測資終於正確之後 開始寫 結果丟上去<br><img src="https://i.imgur.com/cdBrJZy.png" alt=""></p>
<p>想了好久 我到底錯在哪裡 結果是 $\lceil  \rceil$ 的時候寫錯了…</p>
<p>總之 多災多難的一次pB 然後還rated ヽ(`Д´)ノ</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		s.insert(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.size()==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; max(<span class="number">1</span>,((<span class="keyword">int</span>)s.size()<span class="number">-1</span>+k<span class="number">-2</span>)/(k<span class="number">-1</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-C-Discrete-Acceleration"><a href="#Problem-C-Discrete-Acceleration" class="headerlink" title="Problem C - Discrete Acceleration"></a>Problem C - Discrete Acceleration</h2><p><img src="https://i.imgur.com/OPw9N2E.png" alt=""></p>
<p>這題剛點開時想了一下 </p>
<p>示意圖（有點醜）<br><img src="https://i.imgur.com/BmKiPu7.png" alt=""></p>
<p>反正就是有點國小那種追趕問題 不過是相向而行<br><br>這題基本上就分前後討論就好了 <br><br>C++的話可以用deque</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,l;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, tmp;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		v.push_back(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> sa = <span class="number">1</span>, sb = <span class="number">1</span>, apos = <span class="number">0</span>, bpos = l;</span><br><span class="line">	<span class="keyword">while</span>(!v.empty())&#123;</span><br><span class="line">		<span class="keyword">if</span>((v.front()-apos)/sa &lt; (bpos-v.back())/sb)&#123;</span><br><span class="line">			bpos -= (v.front()-apos)/sa*sb;</span><br><span class="line">			ans += (v.front()-apos)/sa;</span><br><span class="line">			apos = v.front();</span><br><span class="line">			sa++;</span><br><span class="line">			v.pop_front();</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>((v.front()-apos)/sa &gt; (bpos-v.back())/sb)&#123;</span><br><span class="line">			apos += (bpos-v.back())/sb*sa;</span><br><span class="line">			ans += (bpos-v.back())/sb;</span><br><span class="line">			bpos = v.back();</span><br><span class="line">			sb++;</span><br><span class="line">			v.pop_back();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ans += (v.front()-apos)/sa;</span><br><span class="line">			apos = v.front();</span><br><span class="line">			bpos = v.back();</span><br><span class="line">			sa++;</span><br><span class="line">			sb++;</span><br><span class="line">			v.pop_front();</span><br><span class="line">			<span class="keyword">if</span>(!v.empty())v.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans += (bpos-apos)/(sa+sb);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Problem-D-Searchlights"><a href="#Problem-D-Searchlights" class="headerlink" title="Problem D - Searchlights"></a>Problem D - Searchlights</h2><p><img src="https://i.imgur.com/muDTaWW.png" alt=""></p>
<p>這題是要移動每個小偷 使得沒有一個小偷的 $x$ 或 $y$ 小於任何一個燈的 $x$ 或 $y$</p>
<p>這題我解完pB之後 一直想不到解答 <br><br>我原本的想法是使用三分搜來找的最小值 <br><br>不過不是WA就是TLE</p>
<p>慘狀<br><img src="https://i.imgur.com/Zrq9xRU.png" alt=""></p>
<p>然後賽後看了其他人的解以及Editorial才會解這題</p>
<p>這題的 $m,n$ 並不大，都小於 2000 <br><br>因此如果我們能有一個 $O(mn)$ 甚至是 $O(mnlogn)$也都能通過</p>
<p>原本的想法是去枚舉增加的 $x$ ，不過 $10^6$ 有點大 不容易去做這件事 <br><br>所以仔細想想後會發現增加的 $x$ 對應答案會成單調性 <br><br>增加的 $x$ 越小 所需增加的y就越大 <br></p>
<p>所以我們可以做一件事 就是做 $nm$ 次 並更新小於 $\Delta x$ 時 小偷的 $y$ 座標應增加的數字 <br></p>
<p>接著我們就可以用後綴最大值來達到這點</p>
<p>複雜度：$O(nm+10^6)$ <br></p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; rb,sl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		rb.push_back(&#123;x,y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		sl.push_back(&#123;x,y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : rb)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> y : sl)&#123;</span><br><span class="line">			<span class="keyword">if</span>(x.first &gt; y.first) <span class="keyword">continue</span>;</span><br><span class="line">			arr[y.first-x.first] = max(arr[y.first-x.first],y.second-x.second+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = N<span class="number">-1</span>;~i;i--)&#123;</span><br><span class="line">		arr[i] = max(arr[i],arr[i+<span class="number">1</span>]);</span><br><span class="line">		ans = min(arr[i]+i,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>Math</tag>
        <tag>Greedy</tag>
        <tag>藍牌</tag>
        <tag>摔分</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI 2014 Wall &amp; IOI 2005 Mountain</title>
    <url>/2020/09/27/IOI-2014-Wall-IOI-2005-Mountain/</url>
    <content><![CDATA[<h1 id="IOI-2014-Wall-amp-IOI-2005-Mountain"><a href="#IOI-2014-Wall-amp-IOI-2005-Mountain" class="headerlink" title="IOI 2014 Wall &amp; IOI 2005 Mountain"></a>IOI 2014 Wall &amp; IOI 2005 Mountain</h1><p>上週瘋狂的在解Codeforces EDU的線段樹題目<br>其中有各式各樣的線段樹題目 而這兩題剛好是過往的IOI題目 所以來紀錄一下解法<br><a id="more"></a></p>
<h3 id="IOI-2014-Wall"><a href="#IOI-2014-Wall" class="headerlink" title="IOI 2014 Wall"></a>IOI 2014 Wall</h3><p>題目：<br>中文：<br> <a href="http://ioi.te.lv/locations/ioi14/contest/day1/wall/twn.pdf">http://ioi.te.lv/locations/ioi14/contest/day1/wall/twn.pdf</a><br>英文：<br> <a href="http://ioi.te.lv/locations/ioi14/contest/day1/wall/wall.pdf">http://ioi.te.lv/locations/ioi14/contest/day1/wall/wall.pdf</a></p>
<p>總而言之，今天有個人建造磚牆，一開始整個牆都沒有任何磚塊，他會進行 $k$ 次操作，<br>每次進行第 $t$ 種操作 給予區間 $[l,r]$ 以及 $h$<br>操作共有兩種</p>
<p>（一）把 $[l,r]$ 高度不到 $h$ 的牆全部提升到 $h$<br><br>（二）把 $[l,r]$ 高度高於 $h$ 的牆全部降低為 $h$</p>
<p>問最後每一面牆的高度為何？</p>
<p>這題用到區間修改 不過只有最後去進行每個點的單點詢問<br>我們可以想想看要如何去進行修改</p>
<p>我們給予線段樹上的每個節點兩個標記 分別紀錄提昇與降低的高度<br>在這裡將他們命名為 $up$, $down$<br>預設先將$up=0$, $down = INF$（$INF$的數值只要大於$100000$就可以了）</p>
<p>在進行區間更新時</p>
<p>當我們要進行提昇的動作<br>修改節點的$up=max(up,h)$, $down=max(down,h)$</p>
<p>而相反的 要降低高度時<br>修改節點的$up=min(up,h)$, $down=min(down,h)$</p>
<p>這樣我們對於節點的標記就完成了</p>
<p>而當我們要下推節點的標記時 我們會有四種動作（$up’,down’$為我們要下推的標記）</p>
<p>$1.up=max(up,up’)$ <br><br>$2.up=min(up,down’)$ <br><br>$3.down=max(down,up’)$ <br><br>$4.down=min(down,down’)$ </p>
<p>仔細想一下 這四種操作分別能夠在提昇與降低時更新節點的數值<br>而最後就可以輸出所有的葉節點了</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> up = <span class="number">0</span>, down = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">	node()&#123;&#125;</span><br><span class="line">&#125; d[<span class="number">4</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> up, <span class="keyword">int</span> down)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ind&gt;=<span class="number">0</span>&amp;&amp;ind&lt;<span class="number">4</span>*N)&#123;</span><br><span class="line">		d[ind].down = min(d[ind].down,down);</span><br><span class="line">		d[ind].down = max(d[ind].down,up);</span><br><span class="line">		d[ind].up = max(d[ind].up,up);</span><br><span class="line">		d[ind].up = min(d[ind].up,down);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_modify</span><span class="params">(<span class="keyword">int</span> mode, <span class="keyword">int</span> ml, <span class="keyword">int</span> mr, <span class="keyword">int</span> val, <span class="keyword">int</span> ind = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = N<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ml&gt;r||mr&lt;l) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(ml&lt;=l&amp;&amp;mr&gt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(mode)&#123;</span><br><span class="line">			d[ind].down = min(d[ind].down,val);</span><br><span class="line">			d[ind].up = min(d[ind].up,val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			d[ind].down = max(d[ind].down,val);</span><br><span class="line">			d[ind].up = max(d[ind].up,val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">	apply(ind&lt;&lt;<span class="number">1</span>,d[ind].up,d[ind].down);</span><br><span class="line">	apply(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d[ind].up,d[ind].down);</span><br><span class="line">	d[ind].up = <span class="number">0</span>, d[ind].down = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">	range_modify(mode,ml,mr,val,ind&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	range_modify(mode,ml,mr,val,ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(l!=n) <span class="built_in">cout</span> &lt;&lt; min(d[ind].up,d[ind].down) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	apply(ind&lt;&lt;<span class="number">1</span>,d[ind].up,d[ind].down);</span><br><span class="line">	apply(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d[ind].up,d[ind].down);</span><br><span class="line">	d[ind].up = <span class="number">0</span>, d[ind].down = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	query(ind&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	query(ind&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="keyword">int</span> mode,l,r,val;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; mode &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">		range_modify(mode<span class="number">-1</span>,l,r,val,<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">	&#125;</span><br><span class="line">	query(<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="IOI-2005-Mountain"><a href="#IOI-2005-Mountain" class="headerlink" title="IOI 2005 Mountain"></a>IOI 2005 Mountain</h3><p>題目：<br>英文：<a href="http://ioi.te.lv/locations/ioi05/contest/day1/mou/mou.pdf">http://ioi.te.lv/locations/ioi05/contest/day1/mou/mou.pdf</a></p>
<p>這題的意思是說有 $n$ 條鐵路軌道 每個火車最高只能爬到 $h$ 的高度<br>他會給予很多次修改鐵路上升的幅度以及每一台火車所能爬到的高度<br>問火車能爬完幾條鐵路</p>
<p>這題其實還滿簡單的 不過要注意的是 $n$ 的範圍 $1&lt;n&lt;10^9$<br>很明顯需要使用動態開點的線段樹</p>
<p>一開始看到這題時 因為Codeforces前面的練習題有「區間加等差數列」還有「第一個大於X的元素」<br>看到時就馬上刻了一棵超級毒瘤的線段樹<br>不過仔細想想 這題根本沒原本想的那麼難</p>
<p>這題需要的只是一棵區間加值的線段樹 然後找到總和大於X的第一個元素</p>
<p>要找大於X的元素時 我們會做的是維護區間元素的最大值<br>所以換成找總和時 則是在每個節點維護區間總和的最大值<br>在這裡我稱他為$mx$</p>
<p>而要維護總和的最大值<br>我們只需要在區間更新時 順便更新每個節點mx的值</p>
<script type="math/tex; mode=display">mx = max(l_{mx},l_{sum}+r_{mx})</script><p>附上我的程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	node *lc, *rc;</span><br><span class="line">	<span class="keyword">int</span> l, r, sum, lz, mx;</span><br><span class="line">	node():lc(<span class="literal">NULL</span>), rc(<span class="literal">NULL</span>), l(<span class="number">0</span>), r(N), sum(<span class="number">0</span>), lz(-INF), mx(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ext</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lc==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			lc = <span class="keyword">new</span> node();</span><br><span class="line">			rc = <span class="keyword">new</span> node();</span><br><span class="line">			lc-&gt;l = l, lc-&gt;r = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			rc-&gt;l = (l+r&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, rc-&gt;r = r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(node *&amp;t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t-&gt;l!=t-&gt;r) t-&gt;ext();</span><br><span class="line">	<span class="keyword">if</span>(t-&gt;lz&gt;-INF)&#123;</span><br><span class="line">		t-&gt;sum = t-&gt;mx = (t-&gt;r-t-&gt;l+<span class="number">1</span>)*t-&gt;lz;</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;l!=t-&gt;r)&#123;</span><br><span class="line">			t-&gt;lc-&gt;lz = t-&gt;lz;</span><br><span class="line">			t-&gt;rc-&gt;lz = t-&gt;lz;</span><br><span class="line">		&#125;</span><br><span class="line">		t-&gt;lz = -INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(node *&amp;t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	apply(t);</span><br><span class="line">	<span class="keyword">if</span>(t-&gt;l &gt; r || t-&gt;r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(t-&gt;l &gt;= l &amp;&amp; t-&gt;r &lt;= r)&#123;</span><br><span class="line">		t-&gt;sum = t-&gt;mx = (t-&gt;r-t-&gt;l+<span class="number">1</span>)*val;</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;l!=t-&gt;r)&#123;</span><br><span class="line">			t-&gt;ext();</span><br><span class="line">			t-&gt;lc-&gt;lz = val;</span><br><span class="line">			t-&gt;rc-&gt;lz = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;ext();</span><br><span class="line">	modify(t-&gt;lc,l,r,val);</span><br><span class="line">	modify(t-&gt;rc,l,r,val);</span><br><span class="line">	t-&gt;sum = t-&gt;lc-&gt;sum + t-&gt;rc-&gt;sum;</span><br><span class="line">	t-&gt;mx = max(t-&gt;lc-&gt;mx, t-&gt;lc-&gt;sum + t-&gt;rc-&gt;mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(node *&amp;t, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	apply(t);</span><br><span class="line">	<span class="keyword">if</span>(t-&gt;l==t-&gt;r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;mx &gt; val) <span class="keyword">return</span> t-&gt;l<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> t-&gt;l;</span><br><span class="line">	&#125;</span><br><span class="line">	apply(t-&gt;lc);</span><br><span class="line">	<span class="keyword">if</span>(t-&gt;lc-&gt;mx &gt; val) <span class="keyword">return</span> query(t-&gt;lc,val);</span><br><span class="line">	<span class="keyword">return</span> query(t-&gt;rc,val-t-&gt;lc-&gt;sum);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio 	</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	node *t = <span class="keyword">new</span> node();</span><br><span class="line">	<span class="keyword">char</span> q;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; q)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q==<span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(q==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> val;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; query(t,val) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> l,r,d;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">			modify(t,l,r,d);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>線段樹</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ 2008, 2009 (北市賽 2017)</title>
    <url>/2020/10/06/TIOJ-2008-2009/</url>
    <content><![CDATA[<p>因為昨天在巴哈上看到</p>
<p>日音醬提到他在校內選拔無法解出這兩題</p>
<p>所以我就決定要來解解看這兩題</p>
<p>剛好也是以往北市賽的題目 就順便練一下吧</p>
<a id="more"></a>
<h2 id="TIOJ-2008-格鬥大賽-Fight"><a href="#TIOJ-2008-格鬥大賽-Fight" class="headerlink" title="TIOJ 2008 - 格鬥大賽 (Fight)"></a>TIOJ 2008 - 格鬥大賽 (Fight)</h2><p><img src="https://i.imgur.com/iUDw6rV.png" alt=""></p>
<p>這題的想法還滿簡單的 就是要去找每個編號最多能夠贏多少人</p>
<p>很直接的就是要去找所有編號勝場數最大的</p>
<p>不過如果我們直接暴搜 複雜度會是 $O(n^2)$</p>
<p>因此 我們需要想到別的方式來維護每個編號的最大值</p>
<p>我們可以很輕易的想到 如果一個人能夠贏過 $x$ 個人</p>
<p>那麼打贏這人的人一定能夠贏過 $x$ 個人以上</p>
<p>這裡用 $w$ 表示每個人的勝場數</p>
<p>我們可以知道若第 $i$ 個人贏過第 $j$ 個人 ($j$ &lt; $i$)<br>且 $i$ 贏過 $i-1,i-2,…, j$個人</p>
<p>那麼 $w_i = w_j + (i-j-1)$</p>
<p>我們可以利用 stack 來維護這個值</p>
<p>或者不使用 stack 直接使用迴圈也可解出這題</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1500000</span>;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,x,y;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		v.push_back(&#123;x,y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!s.empty()&amp;&amp;((v[i].first &gt; v[s.top()].first&amp;&amp;v[i].second &gt;= v[s.top()].second)||(v[i].second&gt;v[s.top()].second&amp;&amp;v[i].first &gt;= v[s.top()].first)))</span><br><span class="line">			s.pop();</span><br><span class="line">		<span class="keyword">if</span>(s.empty())</span><br><span class="line">			ans[i] += i;</span><br><span class="line">		<span class="keyword">else</span> ans[i] += i-s.top()<span class="number">-1</span>;</span><br><span class="line">		s.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty()) s.pop();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;~i;i--)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!s.empty()&amp;&amp;((v[i].first &gt; v[s.top()].first&amp;&amp;v[i].second &gt;= v[s.top()].second)||(v[i].second&gt;v[s.top()].second&amp;&amp;v[i].first &gt;= v[s.top()].first)))</span><br><span class="line">			s.pop();</span><br><span class="line">		<span class="keyword">if</span>(s.empty())</span><br><span class="line">			ans[i] += n<span class="number">-1</span>-i;</span><br><span class="line">		<span class="keyword">else</span> ans[i] += s.top()-i<span class="number">-1</span>;</span><br><span class="line">		s.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *max_element(ans,ans+N) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TIOJ-2009-數字密碼鎖"><a href="#TIOJ-2009-數字密碼鎖" class="headerlink" title="TIOJ 2009 - 數字密碼鎖"></a>TIOJ 2009 - 數字密碼鎖</h2><p><img src="https://i.imgur.com/VFztYYY.png" alt=""></p>
<p>這題感覺就是當年的送分題</p>
<p>這題沒什麼難度</p>
<p>我們先紀錄一開始陣列與最後目標的陣列的數字差</p>
<p>再貪心的由前而後將數字差變為零</p>
<p>當最後有一個或以上數字差不為零 則沒有答案</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> arr[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : arr) <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,tmp;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		<span class="keyword">if</span>(tmp &lt; arr[i]) arr[i] = tmp+<span class="number">9</span>-arr[i];</span><br><span class="line">		<span class="keyword">else</span> arr[i] = tmp-arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n-k;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">		ans += tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k;j++)&#123;</span><br><span class="line">			arr[i+j] = (arr[i+j]-tmp+<span class="number">9</span>)%<span class="number">9</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這兩題感覺難度都不太高</p>
<p>希望今年的題目不要太難 然後想進全國賽 QQ</p>
]]></content>
      <tags>
        <tag>北市賽</tag>
        <tag>TIOJ</tag>
        <tag>貪心</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 臺北市資訊學科能力競賽</title>
    <url>/2020/09/30/TIOJ-2019-Taipei-Contest/</url>
    <content><![CDATA[<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>因為11月要去比北市賽<br><br>今天解了去年北市賽的題目 <br><br>（早自習30分鐘+午休30分鐘+四節下課10分鐘+無數的上課思考）<br><br>不過五題只解了四題 第五題還沒看 <br><br>距離北市賽 還有37天！ 希望有機會進全國賽</p>
<p>題目:<br><a href="https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=ZGVmYXVsdGRvbWFpbnxobGZnb25nenVvc2hpfGd4OjRjMTVmYmY2NzcwY2VlODM">https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=ZGVmYXVsdGRvbWFpbnxobGZnb25nenVvc2hpfGd4OjRjMTVmYmY2NzcwY2VlODM</a></p>
<a id="more"></a>
<h2 id="第一題：-出戰順序-Arrangement"><a href="#第一題：-出戰順序-Arrangement" class="headerlink" title="第一題： 出戰順序 (Arrangement)"></a>第一題： 出戰順序 (Arrangement)</h2><p>TIOJ 2169:<br><a href="https://tioj.ck.tp.edu.tw/problems/2169">https://tioj.ck.tp.edu.tw/problems/2169</a></p>
<p><img src="https://i.imgur.com/BZrx9Sy.png" alt=""></p>
<p>有練過不少題目的人應該都知道有個問題叫做「<a href="https://zh.wikipedia.org/zh-tw/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">約瑟夫斯問題</a>」</p>
<p>這個問題有很多不同的解法 <br><br>有的人可能用Treap之類的資料結構來達到 $O(n log n)$的解 <br><br>不過這個問題有線性的 $O(n)$ 解<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    tmp = (tmp+t)%i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>題目的要求為 給予一個最後的數字 問 $m$ 應為多少 <br><br>這題的範圍是 $1 \leq n,k \leq 10^4$ <br><br>而 $m$ 則為 $2 \leq m \leq 3 \times 10^4$ <br><br>因此我們可以暴搜找出 $m$ 值</p>
<p>複雜度: $O(30000 \times k)$</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">2</span>;t &lt;= <span class="number">30000</span>;t++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">			tmp = (tmp+t)%i;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp++;</span><br><span class="line">		<span class="keyword">if</span>(tmp==k)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第二題：地圖編修-Map"><a href="#第二題：地圖編修-Map" class="headerlink" title="第二題：地圖編修 (Map)"></a>第二題：地圖編修 (Map)</h2><p>TIOJ 2170:<br><a href="https://tioj.ck.tp.edu.tw/problems/2170">https://tioj.ck.tp.edu.tw/problems/2170</a></p>
<p><img src="https://i.imgur.com/WZUAbOc.png" alt=""></p>
<p>這一題第一眼看上去，以為是向量投影 <br><br>不過仔細想一想，這題從題目的說明上看來 <br><br>其實只要解模方程 題目給了 $n$ 個方程式 <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 101     2 101</span><br><span class="line">5 3    &#x3D;&gt; 5 3</span><br><span class="line">3 1       3x 1x</span><br><span class="line">2 2       2y 2y</span><br></pre></td></tr></table></figure>
<p>因此我們有了一個一元模方程組</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{ll}
3x+2y=5 \text{ (mod 101)} \\\\ 
1x+2y=3 \text{ (mod 101)}
\end{array} 
\right.</script><p>要用電腦解方程式有很多作法</p>
<p>用矩陣的解法</p>
<p>$\begin{bmatrix}3 &amp; 2 \\ 1 &amp; 2\end{bmatrix} \begin{bmatrix}x \\ y \end{bmatrix} = \begin{bmatrix}5 \\ 3 \end{bmatrix}$</p>
<p>或者<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84#%E5%85%8B%E6%8B%89%E7%91%AA%E5%AE%9A%E7%90%86">克拉瑪公式</a></p>
<p>以及這題需要使用的<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95">高斯消去法</a><br><br>高斯消去法是基於加減消去法 運用矩陣的列運算來求解</p>
<p>$\begin{bmatrix}3(x) &amp; 2(y) &amp; 5 \\ 1(x) &amp; 2(y) &amp; 3 \end{bmatrix}$</p>
<p>只要我們能夠用列運算將原本的矩陣化為</p>
<p>$\begin{bmatrix}1(x) &amp; 0(y) &amp; x \\ 0(x) &amp; 1(y) &amp; y \end{bmatrix}$</p>
<p>最後一行就會是所有我們要求解的變數了<br><br>而使用高斯消去法解模方程就只是在運算時去執行模運算而已 <br><br>至於如何進行列運算來轉化矩陣 就是留給讀者的練習了<br></p>
<p>複雜度： $O(n^3logm)$ （備註：$logm$是因為求模逆元）</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> MOD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res = (res * n)%MOD;</span><br><span class="line">		n = (n*n)%MOD;</span><br><span class="line">		p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N][N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; MOD;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[j][n-i+<span class="number">2</span>]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!arr[i][i])&#123;</span><br><span class="line">			<span class="comment">//若arr[i][i]為0 與其他行交換 將arr[i][i]變為其他數字</span></span><br><span class="line">			<span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j][i])&#123;</span><br><span class="line">					ok = <span class="literal">false</span>;</span><br><span class="line">					row = j;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ok) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">				swap(arr[i][j],arr[row][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = arr[i][i];</span><br><span class="line">        <span class="comment">//將這一行同除arr[i][i] 使arr[i][i]變為1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">			arr[i][j] = arr[i][j] * fastpow(tmp,MOD<span class="number">-2</span>)%MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">			tmp = arr[j][i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n+<span class="number">1</span>;k++)&#123;</span><br><span class="line">				arr[j][k] = ((arr[j][k]%MOD - arr[i][k]%MOD*tmp%MOD)%MOD+MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i;i--) <span class="built_in">cout</span> &lt;&lt; (arr[i][n+<span class="number">1</span>]+MOD)%MOD &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三題：打卡遊戲-Checkin"><a href="#第三題：打卡遊戲-Checkin" class="headerlink" title="第三題：打卡遊戲 (Checkin)"></a>第三題：打卡遊戲 (Checkin)</h2><p>TIOJ 2171:<br><a href="https://tioj.ck.tp.edu.tw/problems/2171">https://tioj.ck.tp.edu.tw/problems/2171</a></p>
<p><img src="https://i.imgur.com/QdTEMLE.png" alt=""></p>
<p>圖論題<br>這題目其實我看了一陣子才理解<br>題目給的是一張有$A+B$ 個節點與 $k$ 條邊的圖（不一定完全連通）<br>而 $S,M$ 的數值對於這題來說其實完全用不到<br>要用最少車資完成遊戲 我們可以推得 </p>
<script type="math/tex; mode=display">車資=搭乘車數量\times S + M \times 距離和</script><p>距離和不論怎麼做都不會改變 <br><br>因此我們可以將題目的「最少車資」改為「搭乘最少數量」</p>
<p>而我們要找尋搭乘的最少數量 <br><br>我們可以很輕易的知道 如果有 $n$ 個連通塊 <br><br>我們至少要做 $n$ 次才能走完所有邊 <br><br>而每個連通塊需要的次數 我們可以由「<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98#%E5%AE%9A%E7%90%86%E4%BA%8C">一筆畫定理</a>」得知</p>
<p><img src="https://i.imgur.com/TBNrJy4.png" alt=""></p>
<p>因此本題的答案就是</p>
<script type="math/tex; mode=display">\Sigma_{每個連通塊} \text{ }min(奇數節點/2,1)</script><p>複雜度 $O(A+B+K)$ <br><br>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[N];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, visited[N];</span><br><span class="line"><span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	visited[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(adj[u].size()&amp;<span class="number">1</span>) odd++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[v]) dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> a,b,s,m,k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		<span class="comment">//v starts from a+1</span></span><br><span class="line">		adj[u].push_back(a+v);</span><br><span class="line">		adj[a+v].push_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= a+b;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[i]||adj[i].size()==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		odd = <span class="number">0</span>;</span><br><span class="line">		dfs(i);</span><br><span class="line">		ans += max(odd/<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第四題：物種演化-Evolution"><a href="#第四題：物種演化-Evolution" class="headerlink" title="第四題：物種演化 (Evolution)"></a>第四題：物種演化 (Evolution)</h2><p>TIOJ 2172:<br><a href="https://tioj.ck.tp.edu.tw/problems/2172">https://tioj.ck.tp.edu.tw/problems/2172</a></p>
<p><img src="https://i.imgur.com/CvUtQcz.png" alt=""></p>
<p>這題是非常裸的樹上兩點最短距離</p>
<p>就用倍增法或樹壓平找LCA<br><br>之後用 $d = dep[u] - 2*dep[lca(u,v)] + dep[v]$就是答案</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[N];</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v : adj[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v==par) <span class="keyword">continue</span>;</span><br><span class="line">		dep[v] = dep[u]+<span class="number">1</span>;</span><br><span class="line"> 		fa[v][<span class="number">0</span>] = u;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x,y);</span><br><span class="line">	<span class="keyword">int</span> diff = dep[x]-dep[y];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>;~i;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;diff)&#123;</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>;~i;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">			y = fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	x = fa[x][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		u++,v++;</span><br><span class="line">		adj[u].push_back(v);</span><br><span class="line">		adj[v].push_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	dep[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">			fa[j][i] = fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		x++,y++;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dep[x]+dep[y]<span class="number">-2</span>*dep[lca(x,y)] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第五題：搜集寶藏"><a href="#第五題：搜集寶藏" class="headerlink" title="第五題：搜集寶藏"></a>第五題：搜集寶藏</h2><p>TIOJ 2173:<br><a href="https://tioj.ck.tp.edu.tw/problems/2173">https://tioj.ck.tp.edu.tw/problems/2173</a></p>
<p>待補</p>
]]></content>
      <tags>
        <tag>北市賽</tag>
        <tag>TIOJ</tag>
        <tag>約瑟夫斯問題</tag>
        <tag>圖論</tag>
        <tag>高斯消去法</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>TIOJ 2155</title>
    <url>/2020/10/07/TIOJ-2155/</url>
    <content><![CDATA[<h1 id="TIOJ-2155-amp-2151"><a href="#TIOJ-2155-amp-2151" class="headerlink" title="TIOJ 2155 &amp; 2151"></a>TIOJ 2155 &amp; 2151</h1><p>今天Codeforces燒機</p>
<p>所以只能上TIOJ解解題目 (´;ω;`) </p>
<p>然後就發現建中的校內賽有夠難的</p>
<p>果然是全台第一志願</p>
<h2 id="TIOJ-2155-對發票-Again！"><a href="#TIOJ-2155-對發票-Again！" class="headerlink" title="TIOJ 2155 - 對發票 Again！"></a>TIOJ 2155 - 對發票 Again！</h2><p><img src="https://i.imgur.com/PW9YGFI.png" alt=""></p>
<p>看到這題時 發現就是要找所有字串的共同子字串且這個子字串在每個字串中不重複</p>
<p>突然想到不久前才學過的 <a href="https://sam571128.github.io/2020/10/02/Suffix-Array/">Suffix Array</a> 可以做到這件事情</p>
<p>所以就開始刻這題了</p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">ramen</span><br><span class="line">lamian</span><br><span class="line">raaamen</span><br><span class="line">yesiam</span><br><span class="line">diamond </span><br></pre></td></tr></table></figure>
<p>我們先將這些字串串起來 然後找出這幾個的 LCP Array</p>
<p>最後將後綴編號 最後選取所有編號都出現一次的那個 找出LCP值</p>
<p>且與前後比對 就可以找到不重複的共同子字串<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aaamen<span class="meta">#yesiam#diamond$                            編號:3 ,與前一個的LCP: 0</span></span><br><span class="line">aamen<span class="meta">#yesiam#diamond$                             編號:3 ,與前一個的LCP: 2</span></span><br><span class="line">==========================================================================</span><br><span class="line">這段是我們所要選的答案 LCP大小為: <span class="number">2</span> 共同子字串為: <span class="string">&quot;am&quot;</span></span><br><span class="line">am#diamond$                                       編號:<span class="number">4</span> ,與前一個的LCP: <span class="number">1</span></span><br><span class="line">amen#lamian#raaamen#yesiam#diamond$               編號:<span class="number">1</span> ,與前一個的LCP: <span class="number">2</span></span><br><span class="line">amen#yesiam#diamond$                              編號:<span class="number">3</span> ,與前一個的LCP: <span class="number">5</span></span><br><span class="line">amian#raaamen#yesiam#diamond$                     編號:<span class="number">2</span> ,與前一個的LCP: <span class="number">2</span></span><br><span class="line">amond$                                            編號:<span class="number">5</span> ,與前一個的LCP: <span class="number">2</span></span><br><span class="line">==========================================================================</span><br><span class="line">an#raaamen#yesiam#diamond$                        編號:<span class="number">2</span> ,與前一個的LCP: <span class="number">1</span></span><br><span class="line">d$                                                編號:<span class="number">5</span> ,與前一個的LCP: <span class="number">0</span></span><br><span class="line">diamond$                                          編號:<span class="number">5</span> ,與前一個的LCP: <span class="number">1</span></span><br><span class="line">en#lamian#raaamen#yesiam#diamond$                 編號:<span class="number">1</span> ,與前一個的LCP: <span class="number">0</span></span><br><span class="line">en#yesiam#diamond$                                編號:<span class="number">3</span> ,與前一個的LCP: <span class="number">3</span></span><br><span class="line">esiam#diamond$                                    編號:<span class="number">4</span> ,與前一個的LCP: <span class="number">1</span></span><br><span class="line">iam#diamond$                                      編號:<span class="number">4</span> ,與前一個的LCP: <span class="number">0</span></span><br><span class="line">iamond$                                           編號:<span class="number">5</span> ,與前一個的LCP: <span class="number">3</span></span><br><span class="line">ian#raaamen#yesiam#diamond$                       編號:<span class="number">2</span> ,與前一個的LCP: <span class="number">2</span></span><br><span class="line">lamian#raaamen#yesiam#diamond$                    編號:<span class="number">2</span> ,與前一個的LCP: <span class="number">0</span></span><br><span class="line">==========================================================================</span><br><span class="line">這段不是我們要選的答案 LCP大小為: <span class="number">0</span>  共同子字串為: <span class="string">&quot;&quot;</span></span><br><span class="line">m#diamond$                                        編號:<span class="number">4</span> ,與前一個的LCP: <span class="number">0</span></span><br><span class="line">men#lamian#raaamen#yesiam#diamond$                編號:<span class="number">1</span> ,與前一個的LCP: <span class="number">1</span></span><br><span class="line">men#yesiam#diamond$                               編號:<span class="number">3</span> ,與前一個的LCP: <span class="number">4</span></span><br><span class="line">mian#raaamen#yesiam#diamond$                      編號:<span class="number">2</span> ,與前一個的LCP: <span class="number">1</span></span><br><span class="line">mond$                                             編號:<span class="number">5</span> ,與前一個的LCP: <span class="number">1</span></span><br><span class="line">==========================================================================</span><br><span class="line">n#lamian#raaamen#yesiam#diamond$                  編號:<span class="number">1</span> ,與前一個的LCP: <span class="number">0</span></span><br><span class="line">n#raaamen#yesiam#diamond$                         編號:<span class="number">2</span> ,與前一個的LCP:<span class="number">2</span></span><br><span class="line">n#yesiam#diamond$                                 編號:<span class="number">3</span> ,與前一個的LCP:<span class="number">2</span></span><br><span class="line">nd$                                               編號:<span class="number">5</span> ,與前一個的LCP:<span class="number">1</span></span><br><span class="line">ond$                                              編號:<span class="number">5</span> ,與前一個的LCP:<span class="number">0</span></span><br><span class="line">raaamen#yesiam#diamond$                           編號:<span class="number">3</span> ,與前一個的LCP:<span class="number">0</span></span><br><span class="line">ramen#lamian#raaamen#yesiam#diamond$              編號:<span class="number">1</span> ,與前一個的LCP:<span class="number">2</span></span><br><span class="line">siam#diamond$                                     編號:<span class="number">4</span> ,與前一個的LCP:<span class="number">0</span></span><br><span class="line">yesiam#diamond$                                   編號:<span class="number">4</span> ,與前一個的LCP:<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>程式碼<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        title
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="keyword">int</span> pos[], <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;rank)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt[n] = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) cnt[rank[pos[i]]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">int</span> ans[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;~i;i--)&#123;</span><br><span class="line">		ans[cnt[rank[pos[i]]]<span class="number">-1</span>] = pos[i];</span><br><span class="line">		--cnt[rank[pos[i]]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) pos[i] = ans[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只需要在求完Suffix Array之後順便求LCP就好了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_suffix</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos[], <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;lcp)</span></span>&#123;</span><br><span class="line">	s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rank</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="comment">//k = 0</span></span><br><span class="line">	iota(pos,pos+n,<span class="number">0</span>);</span><br><span class="line">	sort(pos,pos+n,[&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> s[a] &lt; s[b]; &#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)&#123; </span><br><span class="line">			rank[pos[i]] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			rank[pos[i]] = rank[pos[i<span class="number">-1</span>]] + (s[pos[i]]!=s[pos[i<span class="number">-1</span>]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//k &gt; 0</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">new_rank</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;(<span class="number">1</span>&lt;&lt;k) &lt; n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">			pos[i] = (pos[i] - (<span class="number">1</span>&lt;&lt;k)%n + n ) % n;</span><br><span class="line">		count_sort(pos,n,rank);</span><br><span class="line">		new_rank[pos[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prev = &#123;rank[pos[i<span class="number">-1</span>]], rank[(pos[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;k))%n]&#125;;</span><br><span class="line">			<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now = &#123;rank[pos[i]], rank[(pos[i]+(<span class="number">1</span>&lt;&lt;k))%n]&#125;;</span><br><span class="line">			new_rank[pos[i]] = new_rank[pos[i<span class="number">-1</span>]] + (prev!=now);</span><br><span class="line">		&#125;</span><br><span class="line">		rank = new_rank;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求LCP Array</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> pi = rank[i];</span><br><span class="line">		<span class="keyword">int</span> j = pos[pi<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k]==s[j+k]) k++;</span><br><span class="line">		lcp[pi] = k;</span><br><span class="line">		k = max(<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N]; <span class="comment">// to maintain the values so that they don&#x27;t repeat</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="built_in">string</span> tmp;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		s += tmp + <span class="string">&quot;#&quot;</span>[i==n<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; tmp.size()+(i!=<span class="number">0</span>);j++)&#123;</span><br><span class="line">			pos[len++] = i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans[s.size()+<span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lcp</span><span class="params">(s.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">	get_suffix(s,ans,lcp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//find the minimum lcp in an interval where no pos repeated</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>;i &lt; s.size();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!v.empty()&amp;&amp;(cnt[pos[ans[i]]]||lcp[i]==<span class="number">0</span>))&#123;</span><br><span class="line">			cnt[v.front()]--;</span><br><span class="line">			v.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		v.push(pos[ans[i]]);</span><br><span class="line">		cnt[pos[ans[i]]]++;</span><br><span class="line">		<span class="keyword">if</span>(v.size()==n)&#123;</span><br><span class="line">			<span class="keyword">int</span> minlen = <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i-n+<span class="number">2</span>;j &lt;= i;j++)&#123;</span><br><span class="line">				minlen = min(lcp[j],minlen);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!(minlen==<span class="number">0</span>||lcp[i-n+<span class="number">1</span>]&gt;=minlen||(i!=s.size()&amp;&amp;lcp[i+<span class="number">1</span>]&gt;=minlen)))&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans[i]+minlen&lt;s.size())&#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; s.substr(ans[i],minlen) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;7122&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>tmp</title>
    <url>/2020/10/08/tmp/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分塊法與莫隊算法</title>
    <url>/2020/10/03/MO-Algorithm/</url>
    <content><![CDATA[<p>今天不知道要學什麼<br>所以就找了一個還沒學過的演算法<br>而<strong>分塊法</strong>和<strong>莫隊算法</strong>是我還沒有碰過的演算法<br>所以就來學一下這兩個演算法吧<br><a id="more"></a></p>
<h2 id="分塊算法-Square-Root-Decomposition-又稱根號算法）"><a href="#分塊算法-Square-Root-Decomposition-又稱根號算法）" class="headerlink" title="分塊算法 Square Root Decomposition (又稱根號算法）"></a>分塊算法 Square Root Decomposition (又稱根號算法）</h2><p>分塊法是個什麼樣的演算法呢？ </p>
<p>其實他跟線段樹的概念非常相似<br>線段樹的作法是將一個陣列劃分為 $2^n$ 的長度去詢問<br><img src="https://i.imgur.com/RslnwZ6.png" alt=""></p>
<p>而分塊法則是分為 $\sqrt{n}$ 塊<br><img src="https://i.imgur.com/30LzJoj.png" alt=""></p>
<p>由於線段樹分為 $2^n$ 的長度 因此詢問時則是 $O(logn)$<br>而分為 $\sqrt{n}$ 的分塊法則是在 $O(\sqrt{n})$ 的時間完成詢問 <br><br>一般的線段樹會需要 $2n$ 或 $4n$ 的空間儲存區間的值<br>而分塊則是需要額外的 $\sqrt{n}$ 的空間儲存<br>如何建立分塊呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    block[i/k] = <span class="comment">//想要儲存的東西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在詢問時 我們會有兩個步驟</p>
<p>(一) 將不再分塊範圍的值用暴力法詢問<br>(二) 詢問區間的分塊</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i/k!=l/k) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//暴力詢問區間左段的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r;i &gt;= l;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i/k!=r/k) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//暴力詢問區間右段的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l/k+<span class="number">1</span>;i &lt; r/k;i++)&#123;</span><br><span class="line">    <span class="comment">//詢問分塊的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能看完程式碼還是不太懂<br>現在就讓我們來看看例題吧</p>
<h2 id="分塊法-例題"><a href="#分塊法-例題" class="headerlink" title="分塊法 例題"></a>分塊法 例題</h2><h3 id="一、區間最小值-Range-Minimum-Query-RMQ"><a href="#一、區間最小值-Range-Minimum-Query-RMQ" class="headerlink" title="一、區間最小值 Range Minimum Query (RMQ)"></a>一、區間最小值 Range Minimum Query (RMQ)</h3><blockquote>
<p>給予 $n$ 個數字的陣列 以及 $q$ 個詢問</p>
<p>每次詢問 $[l,r]$ </p>
<p>請輸出 $[l,r]$ 中的最小值</p>
</blockquote>
<p>線段樹 (Segment Tree) 與稀疏表（Sparse Table) 的經典題<br>而我們也可以嘗試使用分塊法來完成這樣的題目</p>
<p>可以去 <a href="https://zerojudge.tw/ShowProblem?problemid=d539">Zerojudge d539</a> 丟丟看自己的解（不過是區間最大值）</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> block[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i/k!=l/k) <span class="keyword">break</span>;</span><br><span class="line">		ans = min(ans,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = r;i &gt;= l;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i/k!=r/k) <span class="keyword">break</span>;</span><br><span class="line">		ans = min(ans,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l/k+<span class="number">1</span>;i &lt; r/k;i++) ans = min(ans,block[i]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; a[i]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) block[i/k] = min(block[i/k],a[i]);</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		l--,r--;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; query(l,r) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、帶修改的區間最小值"><a href="#二、帶修改的區間最小值" class="headerlink" title="二、帶修改的區間最小值"></a>二、帶修改的區間最小值</h3><p>前面做過區間最小值的題目了<br>但是題目不可能那麼單純只出區間最小值吧<br>線段樹能做到的修改 分塊當然也行<br><br>如果是<strong>單點修改</strong> 修改 $i$ 位置的值<br>我們就直接修改陣列中 $i$ 位置和他所在的分塊的值 複雜度 $O(1)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	arr[i] += x;</span><br><span class="line">	block[i/k] += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果是<strong>區間修改</strong>呢 我們直接修改區間的值呢？<br>僅僅是修改一次 整個複雜度會被提高到 $O(n)$<br>所以我們又要利用到線段樹用過的概念 「懶惰標記」</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l/k+<span class="number">1</span>;i &lt; r/k;i++)&#123;</span><br><span class="line">		block[i] += k*x, lz_tag[i] += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i/k!=l/k) <span class="keyword">break</span>;</span><br><span class="line">		a[i] += x;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="keyword">if</span>(l/k==r/k) <span class="keyword">return</span>; <span class="comment">//如果l和r在同一塊裡面 執行兩次會造成數值加了兩次</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = r;i &gt;= l;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i/k!=r/k) <span class="keyword">break</span>;</span><br><span class="line">		a[i] += x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析上面的程式碼<br>我們在區間加值時 最多會執行 $\sqrt{n}$ 次 （區間內不完全包住的塊總和最多兩塊）<br>因此時間複雜度為 $O(\sqrt{n})$<br><br>而在詢問時　我們也要將懶惰打下去（最左和最右的兩塊）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">	<span class="keyword">if</span>(lz_tag[l/k])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = (l/k)*k; i &lt; (l/k+<span class="number">1</span>)*k;i++)&#123;</span><br><span class="line">			a[i] += lz_tag[l/k];</span><br><span class="line">		&#125;</span><br><span class="line">		lz_tag[l/k] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lz_tag[r/k])&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = (r/k)*k; i &lt; (r/k+<span class="number">1</span>)*k;i++)&#123;</span><br><span class="line">			a[i] += lz_tag[r/k];</span><br><span class="line">		&#125;</span><br><span class="line">		lz_tag[r/k] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i/k!=l/k) <span class="keyword">break</span>;</span><br><span class="line">		ans = min(ans,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = r;i &gt;= l;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i/k!=r/k) <span class="keyword">break</span>;</span><br><span class="line">		ans = min(ans,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l/k+<span class="number">1</span>;i &lt; r/k;i++) ans = min(ans,block[i]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣我們就完成區間加值了</p>
<p>複雜度: $O(n\sqrt{n})$</p>
<h3 id="三、更多例題代補"><a href="#三、更多例題代補" class="headerlink" title="三、更多例題代補"></a>三、更多例題代補</h3><p>代補</p>
<h2 id="莫隊算法-Mo’s-Algorithm"><a href="#莫隊算法-Mo’s-Algorithm" class="headerlink" title="莫隊算法 Mo’s Algorithm"></a>莫隊算法 Mo’s Algorithm</h2><p>莫隊算法是由2009年中國國家代表隊的隊長「莫濤」所提出來的<br>一種處理區間問題的離線處理演算法 時間複雜度也非常好</p>
<h3 id="什麼是莫隊算法"><a href="#什麼是莫隊算法" class="headerlink" title="什麼是莫隊算法"></a>什麼是莫隊算法</h3><p>首先，我們先來看看一個問題</p>
<blockquote>
<p>給予 $n$ 項的陣列以及 $q$ 個詢問<br>每次詢問 $[l,r]$ 問在區間內 共有幾個不同的數字<br>$1 \leq n \leq 10^5，1 \leq q \leq n$</p>
</blockquote>
<p>我們如何去思考這個問題呢</p>
<p>如果我們用暴力的方式去處理這個問題 詢問的複雜度會是 $O(n)$</p>
<p>如果我們有 $q$ 次詢問 複雜度就會是 $O(qn)$</p>
<p>這樣子的時間無法過這個題目 <br><br>那我們換個想法 我們有兩個指針 $l,r$ </p>
<p>我們知道 $[l,r]$ 這個區間的答案 </p>
<p>我們可以在 $O(1)$或 $O(logn)$ 的時間找到 $[l-1,r],[l+1,r],[l,r-1],[l,r+1]$答案</p>
<p>我們用這兩個指針加加減減去找到詢問的區間的答案：<br>用一個陣列 $cnt$ 紀錄每個數字的出現次數  </p>
<p>當 $cnt[val] = 1$ 的時候 就代表多了一個數字</p>
<p>利用這個想法 我們可以寫出下面這樣的程式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N], cnt[N], tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[arr[pos]]) tmp++;</span><br><span class="line">	cnt[arr[pos]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	cnt[arr[pos]]--;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[arr[pos]]) tmp--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ql,qr;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; ql) sub(l++);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; ql) add(--l);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; qr) add(++r);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; qr) sub(r--);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不過你會發現 這樣子的程式<br>當詢問很多時 指針會一直來來回回的<br>時間複雜度也不會很好 大概是 $O(n^2)$ 吧<br><br>因此 莫隊算法就是建立在這個的基礎上去優化這種解法</p>
<p>我們可以經由排序來使這個演算法在 $O(n\sqrt{n})$ 的時間完成所有詢問</p>
<h2 id="如何使用莫隊算法"><a href="#如何使用莫隊算法" class="headerlink" title="如何使用莫隊算法"></a>如何使用莫隊算法</h2><p>我們將 $q$ 筆詢問 分別<strong>依照 $l$ 所在的分塊進行排序</strong><br>如果 $l$ 所在的分塊相等 則<strong>依照 $r$ 進行排序</strong><br>只要這樣做之後就能使原本 $O(n^2)$ 的解法降低為 $O(n\sqrt{n})$ 了</p>
<p>因為每一個分塊的詢問都依照 $r$ 進行排序了 </p>
<p>因此最多只要 $O(n\sqrt{n})$ 就能完成所有答案了</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], cnt[N], bid[N], l = <span class="number">1</span>, r = <span class="number">0</span>, tmp= <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> query b)&#123;</span><br><span class="line">		<span class="keyword">return</span> (l/k == b.l/k ? r &lt; b.r : l/k &lt; b.l/k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[a[pos]]) tmp++;</span><br><span class="line">	cnt[a[pos]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	--cnt[a[pos]];</span><br><span class="line">	<span class="keyword">if</span>(!cnt[a[pos]]) tmp--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	k = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="built_in">vector</span>&lt;query&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> ans[m];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> ql, qr;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; ql &gt;&gt; qr;</span><br><span class="line">		Q.push_back(&#123;ql,qr,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q.begin(),Q.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q : Q)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; q.l) sub(l++);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; q.l) add(--l);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; q.r) add(++r);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; q.r) sub(r--);</span><br><span class="line">		ans[q.id] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這樣就完成區間共幾個不同數字的詢問了</p>
<p>可以去<a href="https://www.spoj.com/problems/DQUERY/">SPOJ-DQUERY</a>解解看這題</p>
<h2 id="莫隊算法-例題"><a href="#莫隊算法-例題" class="headerlink" title="莫隊算法 例題"></a>莫隊算法 例題</h2><h3 id="一、區間眾數"><a href="#一、區間眾數" class="headerlink" title="一、區間眾數"></a>一、區間眾數</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=b417">Zerojudge題目連結</a></p>
<p>這題要知道的是眾數的出現次數以及眾數有幾個<br>我們可以用一個陣列 $cnt$ 紀錄每個數字的出現次數<br>然後再用另外一個陣列紀錄出現次數的次數<br>這樣我們就可以在 $O(1)$ 時間維護我們的答案了</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (query b)&#123;</span><br><span class="line">		<span class="keyword">return</span> (l/k == b.l/k ? r &lt; b.r : l/k &lt; b.l/k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a[N], cnt[N], cntcnt[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	cntcnt[cnt[val]]--;</span><br><span class="line">	cnt[val]++;</span><br><span class="line">	cntcnt[cnt[val]]++;</span><br><span class="line">	<span class="keyword">if</span>(cntcnt[cnt[val]] == <span class="number">1</span>) ans = max(cnt[val],ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	cntcnt[cnt[val]]--;</span><br><span class="line">	cnt[val]--;</span><br><span class="line">	cntcnt[cnt[val]]++;</span><br><span class="line">	<span class="keyword">if</span>(ans==cnt[val]+<span class="number">1</span>&amp;&amp;cntcnt[cnt[val]+<span class="number">1</span>]==<span class="number">0</span>) ans = cnt[val];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">vector</span>&lt;query&gt; Q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		Q.push_back(&#123;l,r,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans1[m], ans2[m];</span><br><span class="line">	sort(Q.begin(),Q.end());</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">	cntcnt[<span class="number">0</span>] = n;</span><br><span class="line">	<span class="keyword">for</span>(query q : Q)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; q.l) sub(a[l++]);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; q.l) add(a[--l]);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; q.r) add(a[++r]);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; q.r) sub(a[r--]);</span><br><span class="line">		ans1[q.id] = ans, ans2[q.id] = cntcnt[ans];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) <span class="built_in">cout</span> &lt;&lt; ans1[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、Codeforces-617E-XOR-and-Favorite-Number"><a href="#二、Codeforces-617E-XOR-and-Favorite-Number" class="headerlink" title="二、Codeforces 617E - XOR and Favorite Number"></a>二、Codeforces 617E - XOR and Favorite Number</h3><p><a href="https://codeforces.com/problemset/problem/617/E">題目連結</a></p>
<p>這題要維護的是區間的XOR值為他所給的數字</p>
<p>我們都知道XOR的性質是 $a \oplus b = c$ 則 $c \oplus b = a$</p>
<p>然後XOR和加法一樣 求區間和我們會使用前綴和 要求區間XOR也可以使用前綴XOR來求解</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (query b)&#123;</span><br><span class="line">		<span class="keyword">return</span> (l/k == b.l/k ? r &lt; b.r : l/k &lt; b.l/k); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N], pref[N], cnt[<span class="number">1</span>&lt;&lt;<span class="number">20</span>], tmp, num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	tmp += cnt[val ^ num];</span><br><span class="line">	cnt[val]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	cnt[val]--;</span><br><span class="line">	tmp -= cnt[val ^ num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; num;</span><br><span class="line">	k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		pref[i] = pref[i<span class="number">-1</span>]^arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;query&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> ans[m];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		l--; <span class="comment">//由於我們做的是前綴XOR 所以區間XOR = pref[r] ^ pref[l-1]</span></span><br><span class="line">		Q.push_back(&#123;l,r,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q.begin(),Q.end());</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q : Q)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; q.l) sub(pref[l++]);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; q.l) add(pref[--l]);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; q.r) add(pref[++r]);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; q.r) sub(pref[r--]);</span><br><span class="line">		ans[q.id] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Codeforces-877F-Ann-and-Books"><a href="#Codeforces-877F-Ann-and-Books" class="headerlink" title="Codeforces 877F - Ann and Books"></a>Codeforces 877F - Ann and Books</h3><p><a href="https://codeforces.com/problemset/problem/877/F">題目連結</a></p>
<blockquote>
<p>給予 $n$ 本書（數學或經濟）以及一個 $k$ 值</p>
<p>問一個區間有幾個子區間的數學書比經濟多 $k$ 本  </p>
</blockquote>
<p>這題跟上面那題XOR有異曲同工之妙<br>基本兩題就差在XOR與加法而已</p>
<p>這題我們可以把經濟的書以負的做計算去做前綴和<br>左界的更新與右界的更新也有點不同<br>然後剩下的作法與上一題一模一樣<br>不過這題不同點是 $k$ 的值很大 沒有辦法使用陣列來維護<br>如果使用 map 來維護 還是會因為 $O(q\sqrt{n}\log{n})$ 太大而TLE  </p>
<p>因此 這題我們要用到離散化的技巧</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r,id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (query b)&#123;</span><br><span class="line">		<span class="keyword">return</span> (l/k == b.l/k ? r &lt; b.r : l/k &lt; b.l/k); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N], pref[N], tmp, num, up[N], down[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addl</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	tmp += cnt[up[i]];</span><br><span class="line">	cnt[arr[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addr</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	tmp += cnt[down[i]];</span><br><span class="line">	cnt[arr[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subl</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	cnt[arr[i]]--;</span><br><span class="line">	tmp -= cnt[up[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subr</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	cnt[arr[i]]--;</span><br><span class="line">	tmp -= cnt[down[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; num;</span><br><span class="line">	k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		<span class="keyword">if</span>(arr[i]==<span class="number">2</span>) arr[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		arr[i]*=a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		pref[i] = pref[i<span class="number">-1</span>] + arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		v.push_back(pref[i]);</span><br><span class="line">		v.push_back(pref[i]+num);</span><br><span class="line">		v.push_back(pref[i]-num);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(v.begin(),v.end());</span><br><span class="line">	v.resize(unique(v.begin(),v.end())-v.begin());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		arr[i] = lower_bound(v.begin(),v.end(),pref[i]) - v.begin() + <span class="number">1</span>;</span><br><span class="line">		up[i] = lower_bound(v.begin(),v.end(),pref[i]+num) - v.begin() + <span class="number">1</span>;</span><br><span class="line">		down[i] = lower_bound(v.begin(),v.end(),pref[i]-num) - v.begin() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> ans[m];</span><br><span class="line">	<span class="built_in">vector</span>&lt;query&gt; Q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		l--;</span><br><span class="line">		Q.push_back(&#123;l,r,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q.begin(),Q.end());</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q : Q)&#123;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; q.l) subl(l++);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; q.l) addl(--l);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; q.r) addr(++r);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; q.r) subr(r--);</span><br><span class="line">		ans[q.id] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、更多例題代補"><a href="#四、更多例題代補" class="headerlink" title="四、更多例題代補"></a>四、更多例題代補</h3><p>代補</p>
<h2 id="帶修改莫隊-10-4更"><a href="#帶修改莫隊-10-4更" class="headerlink" title="帶修改莫隊 (10/4更)"></a>帶修改莫隊 (10/4更)</h2><p>既然有區間詢問 那我們當然也需要區間更新阿</p>
<p>莫隊算法當然也能夠做到區間更新</p>
<p>我們將上面的題目做一點小修改</p>
<blockquote>
<p>給予 $n$ 項的陣列以及 $q$ 個詢問或操作</p>
<p>每次詢問 $[l,r]$ 問在區間內 共有幾個不同的數字</p>
<p>每次操作給予 $x,v$  將陣列第 $x$ 個位置的數字改為 $v$</p>
<p>$1 \leq n \leq 10^5，1 \leq q \leq n$</p>
</blockquote>
<p>如何做到這一點呢</p>
<p>當莫隊將詢問做排序之後 我們該如何考慮到修改呢？<br><br>這裡 我們可以將原本的 Query 增加一個變數 $t$ 表示時間</p>
<p>在排序時 這個 $t$ 也會是我們要考慮的一部分</p>
<p>我們會依照詢問的 $l$ 所在的分塊做排序 若相同 則用 $r$ 所在的分塊排序</p>
<p>若 $r$ 所在的分塊相同 我們則依照 $t$ 去做排序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, t, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (query b)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(l/k==b.l/k)&#123;</span><br><span class="line">                <span class="comment">//l的分塊相同</span></span><br><span class="line">                <span class="keyword">if</span>(r/k==b.r/k)&#123;</span><br><span class="line">                    <span class="comment">//r的分塊相同</span></span><br><span class="line">                    <span class="keyword">return</span> t &lt; b.t;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> r/k &lt; b.r/k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> l/k &lt; b.l/k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>就像上面那樣做 然後我們在詢問時 也要多一個 $t$ 的指針<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; q.l) sub(arr[l++]);</span><br><span class="line"><span class="keyword">while</span>(l &gt; q.l) add(arr[--l]);</span><br><span class="line"><span class="keyword">while</span>(r &lt; q.r) add(arr[++r]);</span><br><span class="line"><span class="keyword">while</span>(r &gt; q.r) sub(arr[r--]);</span><br><span class="line"><span class="keyword">while</span>(t &lt; q.t) modify(Q[i],M[++t]);</span><br><span class="line"><span class="keyword">while</span>(t &gt; q.t) modify(Q[i],M[t--]);</span><br></pre></td></tr></table></figure></p>
<p>然後修改時 如果修改的位置在 $[l,r]$ 以內</p>
<p>我們就要修改答案的值 不然就直接修改陣列中的值就可以了</p>
<p>這邊有個很重要的一點 就是分塊的大小不在是 $\sqrt{n}$ 了</p>
<p>我們必須將分塊的大小設為 $\sqrt[3]{n^2}$ 才會有最佳的複雜度</p>
<p>而帶修改莫隊的複雜度為 $O(\sqrt[3]{n^5})$ 也是已經把 $O(n^2)$ 的複雜度降低非常多了</p>
<p>而上面例題的程式碼我附在這裡 題目可以去 <a href="https://www.luogu.com.cn/problem/P1903">洛谷P1903</a> 解解看<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, t, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (query b)&#123;</span><br><span class="line">		<span class="keyword">return</span> (l/k==b.l/k  ? (r/k == b.r/k ? t &lt; b.t : r/k &lt; b.r/k) : l/k &lt; b.l/k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Q[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upd</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos,x;</span><br><span class="line">&#125; M[N];	</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N], cnt[S], ans[N], tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[val]) tmp++;</span><br><span class="line">	cnt[val]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	cnt[val]--;</span><br><span class="line">	<span class="keyword">if</span>(!cnt[val]) tmp--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(query x, upd &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.l &lt;= y.pos &amp;&amp; y.pos &lt;= x.r)&#123;</span><br><span class="line">		sub(arr[y.pos]);</span><br><span class="line">		add(y.x);</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr[y.pos],y.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	k = <span class="built_in">pow</span>(n,(<span class="keyword">double</span>)<span class="number">2</span>/(<span class="keyword">double</span>)<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">	<span class="keyword">int</span> tid = <span class="number">0</span>, qid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> q;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">		<span class="keyword">if</span>(q==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			Q[qid] = &#123;l,r,tid,qid&#125;;</span><br><span class="line">			qid++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> x, val;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; val;</span><br><span class="line">			++tid;</span><br><span class="line">			M[tid] = &#123;x,val&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q,Q+qid);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; qid;i++)&#123;</span><br><span class="line">		<span class="keyword">auto</span> q = Q[i];</span><br><span class="line">		<span class="keyword">while</span>(l &lt; q.l) sub(arr[l++]);</span><br><span class="line">		<span class="keyword">while</span>(l &gt; q.l) add(arr[--l]);</span><br><span class="line">		<span class="keyword">while</span>(r &lt; q.r) add(arr[++r]);</span><br><span class="line">		<span class="keyword">while</span>(r &gt; q.r) sub(arr[r--]);</span><br><span class="line">		<span class="keyword">while</span>(t &lt; q.t) modify(Q[i],M[++t]);</span><br><span class="line">		<span class="keyword">while</span>(t &gt; q.t) modify(Q[i],M[t--]);</span><br><span class="line">		ans[q.id] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; qid;i++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="帶修改莫隊-例題"><a href="#帶修改莫隊-例題" class="headerlink" title="帶修改莫隊 例題"></a>帶修改莫隊 例題</h2><h3 id="一、Codeforces-940F-Machine-Learning"><a href="#一、Codeforces-940F-Machine-Learning" class="headerlink" title="一、Codeforces 940F - Machine Learning"></a>一、Codeforces 940F - Machine Learning</h3><p><a href="https://codeforces.com/problemset/problem/940/F">題目連結</a></p>
<blockquote>
<p>給一個 $n$ 項的陣列 以及 $q$ 行 Query<br>有兩種 Query<br><br>（一）區間詢問 $Mex$ 值 ($Mex$ 是一陣列中最小未出現的非負整數)</p>
<p>（二）單點修改<br><br> $1 \leq n,q \leq 10^5$</p>
</blockquote>
<p>這題也是很裸的帶修改莫隊 可以自己解看看<br>時間複雜度: $O(n^{\frac{5}{3}})$</p>
<h3 id="二、更多例題代補"><a href="#二、更多例題代補" class="headerlink" title="二、更多例題代補"></a>二、更多例題代補</h3><p>代補</p>
<h2 id="樹上莫隊"><a href="#樹上莫隊" class="headerlink" title="樹上莫隊"></a>樹上莫隊</h2><p>代補</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>今天學了莫隊算法之後 覺得這個演算法真的很厲害<br>不但很好使用 也有很多應用：樹上莫隊、帶修改莫隊之類的<br>不過自己還沒學到那麼多<br>這篇文章也會持續隨著自己的學習更新</p>
]]></content>
      <tags>
        <tag>教學</tag>
        <tag>莫隊算法</tag>
        <tag>分塊法</tag>
      </tags>
  </entry>
  <entry>
    <title>Suffix Array 後綴數組</title>
    <url>/2020/10/02/Suffix-Array/</url>
    <content><![CDATA[<p>因為看到電神「雞塊」在「<a href="https://rk42745417.github.io/">雞塊的競程隨筆</a>」介紹了Suffix Array</p>
<p>今天上Codeforces的EDU學了Suffix Array</p>
<p>覺得Suffix Array真的是一個還滿神奇的東西的</p>
<p>因此決定來紀錄一下怎麼找Suffix Array以及其用途</p>
<a id="more"></a>
<h2 id="什麼是Suffix-Array"><a href="#什麼是Suffix-Array" class="headerlink" title="什麼是Suffix Array"></a>什麼是Suffix Array</h2><p>Suffix Array在維基百科上面被稱為「後綴數組」<br><br>不過他的寫法我看不太懂(´_ゝ`) </p>
<p><img src="https://i.imgur.com/l1pix1F.png" alt=""></p>
<p>總而言之，假設我們有一字串，就叫他aabbaa好了</p>
<p>我們找出這個字串的所有後綴並列出來 （數字為字串從第幾個字元開始的後綴字串）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> aabbaa</span><br><span class="line"><span class="number">1</span> abbaa</span><br><span class="line"><span class="number">2</span> bbaa</span><br><span class="line"><span class="number">3</span> baa</span><br><span class="line"><span class="number">4</span> aa</span><br><span class="line"><span class="number">5</span> a</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><br>有這六個 而我們將他們以字典序去做排列 會得到下面這個<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span> a</span><br><span class="line"><span class="number">4</span> aa</span><br><span class="line"><span class="number">0</span> aabbaa</span><br><span class="line"><span class="number">1</span> abbaa</span><br><span class="line"><span class="number">3</span> baa</span><br><span class="line"><span class="number">2</span> bbaa</span><br></pre></td></tr></table></figure><br>而 $\text{6 5 4 0 1 3 2}$ 就是我們要找的Suffix Array <br><br>他的用途我們會在這篇文章後面提到</p>
<h2 id="如何找到Suffix-Array-Naive-Solution"><a href="#如何找到Suffix-Array-Naive-Solution" class="headerlink" title="如何找到Suffix Array (Naive Solution)"></a>如何找到Suffix Array (Naive Solution)</h2><p>如果要做到這件事 你應該會覺得很簡單 </p>
<p>因為我們需要做的就只是把所有後綴給找出來存在陣列中</p>
<p>並用各種排序法或語言內建的sort去排序<br><br></p>
<p>例如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">int</span> n = s.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">-1</span>;i--)&#123;</span><br><span class="line">	v.push_back(&#123;tmp,i+<span class="number">1</span>&#125;);</span><br><span class="line">	<span class="keyword">if</span>(i!=<span class="number">-1</span>)tmp = s[i] + tmp;</span><br><span class="line">&#125;</span><br><span class="line">sort(v.begin(),v.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p : v) <span class="built_in">cout</span> &lt;&lt; p.second &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><br>結果會是<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbaa</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">5</span> a</span><br><span class="line"><span class="number">4</span> aa</span><br><span class="line"><span class="number">0</span> aabbaa</span><br><span class="line"><span class="number">1</span> abbaa</span><br><span class="line"><span class="number">3</span> baa</span><br><span class="line"><span class="number">2</span> bbaa</span><br></pre></td></tr></table></figure></p>
<p>不過讓我們來分析一下 （用 $n$ 表示字串長度) </p>
<p>所有後綴的字串長度會是 $n,(n-1),(n-2),(n-3),…,2,1$ </p>
<p>全部相加起來則會是 $\frac{n(n+1)}{2}$ 的空間 </p>
<p>當 $n$ 的值大到 $10^4,10^5,10^6$ 的時候 空間複雜度就會爆掉</p>
<p>然後再加上排序的複雜度也是不太理想 $O(nlogn \times |s|)$</p>
<p>總共複雜度會達到 $O(n^2logn)$<br><br></p>
<h2 id="改進找到Suffix-Array的方式"><a href="#改進找到Suffix-Array的方式" class="headerlink" title="改進找到Suffix Array的方式"></a>改進找到Suffix Array的方式</h2><p>由於上面的方式實在是非常沒有效率又佔空間 <br><br>如果我們只紀錄Suffix Array的數值 我們所需要的空間複雜度則為 $O(n)$ <br></p>
<p>為了方便起見 我們在字串後面加上 「\$」 （\$的字典序小於所有字母） <br></p>
<p>並把字串讓字串形成環 字串長度也加到 $2^k$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbaa$</span><br><span class="line"><span class="number">0</span> aabbaa$a</span><br><span class="line"><span class="number">1</span> abbaa$aa</span><br><span class="line"><span class="number">2</span> bbaa$aab</span><br><span class="line"><span class="number">3</span> baa$aabb</span><br><span class="line"><span class="number">4</span> aa$aabba</span><br><span class="line"><span class="number">5</span> a$aabbaa</span><br><span class="line"><span class="number">6</span> $aabbaa$</span><br><span class="line">  <span class="number">01234567</span> =&gt; 字串長度:<span class="number">2</span>^<span class="number">3</span> =&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>排序之後則變成<br><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbaa$</span><br><span class="line"><span class="number">6</span> $aabbaa$</span><br><span class="line"><span class="number">5</span> a$aabbaa</span><br><span class="line"><span class="number">4</span> aa$aabba</span><br><span class="line"><span class="number">0</span> aabbaa$a</span><br><span class="line"><span class="number">1</span> abbaa$aa</span><br><span class="line"><span class="number">3</span> baa$aabb</span><br><span class="line"><span class="number">2</span> bbaa$aab</span><br></pre></td></tr></table></figure><br>我們如何去排序Suffix Array呢？<br><br>我們先分別找到 $k=0, k=1, k=2,…$ 時的排序 <br><br>我們可以用 $k=0$ 去推出 $k=1$ 的狀況 <br></p>
<p>我們先找出每個後綴字串的前 $2^k$ 個字元<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k=<span class="number">0</span>        k=<span class="number">1</span>         k=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">aabbaa$    aabbaa$     aabbaa$</span><br><span class="line"><span class="number">0</span> a        <span class="number">0</span> aa        <span class="number">0</span> aabb</span><br><span class="line"><span class="number">1</span> a        <span class="number">1</span> ab        <span class="number">1</span> abba</span><br><span class="line"><span class="number">2</span> b        <span class="number">2</span> bb        <span class="number">2</span> bbaa</span><br><span class="line"><span class="number">3</span> b        <span class="number">3</span> ba        <span class="number">3</span> baa$</span><br><span class="line"><span class="number">4</span> a        <span class="number">4</span> aa        <span class="number">4</span> aa$a</span><br><span class="line"><span class="number">5</span> a        <span class="number">5</span> a$        <span class="number">5</span> a$aa</span><br><span class="line"><span class="number">6</span> $        <span class="number">6</span> $a        <span class="number">6</span> $aab</span><br></pre></td></tr></table></figure></p>
<p>進行排序之後會得到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k=<span class="number">0</span>        k=<span class="number">1</span>         k=<span class="number">2</span></span><br><span class="line">aabbaa$    aabbaa$     aabbaa$</span><br><span class="line"><span class="number">6</span> $        <span class="number">6</span> $a        <span class="number">6</span> $aabb</span><br><span class="line"><span class="number">0</span> a        <span class="number">5</span> a$        <span class="number">5</span> a$aa</span><br><span class="line"><span class="number">1</span> a        <span class="number">0</span> aa        <span class="number">4</span> aa$a</span><br><span class="line"><span class="number">4</span> a        <span class="number">4</span> aa        <span class="number">0</span> aabb</span><br><span class="line"><span class="number">5</span> a        <span class="number">1</span> ab        <span class="number">1</span> abba</span><br><span class="line"><span class="number">2</span> b        <span class="number">3</span> ba        <span class="number">3</span> baa$</span><br><span class="line"><span class="number">3</span> b        <span class="number">2</span> bb        <span class="number">2</span> bbaa</span><br></pre></td></tr></table></figure>
<p>如何使用 $k=0$ 的 Suffix Array 去得到 $k=1$ 的值呢？<br><br>我們先挑出 $k=0$ 來觀察 並把字元的Rank寫上去(離散化)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k=<span class="number">0</span>      </span><br><span class="line">aabbaa$ Rank</span><br><span class="line"><span class="number">6</span> $      <span class="number">0</span></span><br><span class="line"><span class="number">0</span> a      <span class="number">1</span></span><br><span class="line"><span class="number">1</span> a      <span class="number">1</span></span><br><span class="line"><span class="number">4</span> a      <span class="number">1</span></span><br><span class="line"><span class="number">5</span> a      <span class="number">1</span></span><br><span class="line"><span class="number">2</span> b      <span class="number">2</span></span><br><span class="line"><span class="number">3</span> b      <span class="number">2</span></span><br></pre></td></tr></table></figure><br>有了Rank的值之後 我們就可以用他來得到 $k=1$ 時的數值了 <br><br>用這個方式去排序就可以得到答案了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k=<span class="number">1</span>                               k=<span class="number">1</span></span><br><span class="line">aabbaa$    對應Rank                aabbaa$    對應Rank</span><br><span class="line"><span class="number">6</span> $a        <span class="number">0</span> <span class="number">1</span>                   <span class="number">6</span> $a        <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> aa        <span class="number">1</span> <span class="number">1</span>                   <span class="number">5</span> a$        <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ab        <span class="number">1</span> <span class="number">2</span>         排序Rank   <span class="number">0</span> aa        <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> aa        <span class="number">1</span> <span class="number">1</span>         =======&gt;  <span class="number">4</span> aa        <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> a$        <span class="number">1</span> <span class="number">0</span>                   <span class="number">1</span> ab        <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> bb        <span class="number">2</span> <span class="number">2</span>                   <span class="number">3</span> ba        <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> ba        <span class="number">2</span> <span class="number">1</span>                   <span class="number">2</span> bb        <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>之後再去用上面的資料得到新的Rank與Suffix Array <br><br>我們就可以再用其去求得 $k=2,k=3,…$ 的值了</p>
<p>時間複雜度: $O(nlogn+nlogn \times logn) = O(nlog^2n)$ <br><br>（一開始的 $nlogn$ 為排序單個字元， 後面的 $nlogn$ 為排序pair，而我們會做 $logn$ 次</p>
<p>目前的程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> n = s.size();</span><br><span class="line"><span class="keyword">int</span> pos[n], rank[n];</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//k = 0</span></span><br><span class="line">    <span class="comment">//tmp的作用為暫存我們之後要排序的東西</span></span><br><span class="line">    vector&lt;pair&lt;char,int&gt;&gt; tmp(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) tmp[i] = &#123;s[i],i&#125;;</span><br><span class="line">    sort(tmp.begin(),tmp.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) pos[i] = v[i].second;</span><br><span class="line">    rank[pos[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i].first == tmp[i<span class="number">-1</span>].first) rank[pos[i]] = rank[pos[i<span class="number">-1</span>]];</span><br><span class="line">        <span class="keyword">else</span> rank[pos[i]] = rank[pos[i<span class="number">-1</span>]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>&lt;&lt;k &lt;= n)&#123;</span><br><span class="line">    <span class="comment">//tmp的作用為暫存我們之後要排序的東西</span></span><br><span class="line">    vector&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt; tmp(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) v[i] = &#123;&#123;rank[i],rank[(i+(<span class="number">1</span>&lt;&lt;k))%n]&#125;,i&#125;;</span><br><span class="line">    sort(tmp.begin(),tmp.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) pos[i] = tmp[i].second;</span><br><span class="line">    rank[pos[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i].first == tmp[i<span class="number">-1</span>].first) rank[pos[i]] = rank[pos[i<span class="number">-1</span>]];</span><br><span class="line">        <span class="keyword">else</span> rank[pos[i]] = rank[pos[i<span class="number">-1</span>]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : pos) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="更進一步的改善複雜度"><a href="#更進一步的改善複雜度" class="headerlink" title="更進一步的改善複雜度"></a>更進一步的改善複雜度</h2><p>一般來說 排序所使用的複雜度為 $O(nlogn)$ <br><br>但是幾種排序能做到線性的排序</p>
<p>比較常見的為<a href="https://en.wikipedia.org/wiki/Radix_sort">Radix Sort</a>及<a href="https://zh.wikipedia.org/zh-tw/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">Counting Sort</a> <br><br>在這裡不細講這兩種排序如何達成 直接丟一張維基百科上面的說明 <br></p>
<p>Counting Sort:<br><img src="https://i.imgur.com/nwt427l.png" alt=""></p>
<p>Radix Sort則是對每一位都去進行Counting Sort</p>
<p>複雜度: <br><br>Counting Sort: $O(n+k)$ ($k$ 為陣列的範圍) <br><br>Radix Sort: $O(d\times(n+k))$ ($d$ 為幾位數字)</p>
<p>而我們這裡就可以將原本排序pair的 $O(nlogn \times logn)$ <br><br>用這兩種排序變為 $O(n\times logn)$</p>
<p>因此求Suffix Array的複雜度降低為 $O(nlogn+nlogn)=O(nlogn)$</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;rank)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = pos.size();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : pos) cnt[rank[i]].push_back(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, idx = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt[i])</span><br><span class="line">			pos[idx++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_suffix</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos)</span></span>&#123;</span><br><span class="line">	s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rank</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="comment">//k = 0</span></span><br><span class="line">	iota(pos.begin(),pos.end(),<span class="number">0</span>);</span><br><span class="line">	sort(pos.begin(),pos.end(),[&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> s[a] &lt; s[b]; &#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)&#123; </span><br><span class="line">			rank[pos[i]] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			rank[pos[i]] = rank[pos[i<span class="number">-1</span>]] + (s[pos[i]]!=s[pos[i<span class="number">-1</span>]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//k &gt; 0</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">new_rank</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;(<span class="number">1</span>&lt;&lt;k) &lt;= n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">			pos[i] = (pos[i] - (<span class="number">1</span>&lt;&lt;k)%n + n ) % n;</span><br><span class="line">		count_sort(pos,rank);</span><br><span class="line">		new_rank[pos[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prev = &#123;rank[pos[i<span class="number">-1</span>]], rank[(pos[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;k))%n]&#125;;</span><br><span class="line">			<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now = &#123;rank[pos[i]], rank[(pos[i]+(<span class="number">1</span>&lt;&lt;k))%n]&#125;;</span><br><span class="line">			new_rank[pos[i]] = new_rank[pos[i<span class="number">-1</span>]] + (prev!=now);</span><br><span class="line">		&#125;</span><br><span class="line">		rank = new_rank;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(s.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">	get_suffix(s,ans);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.substr(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>接下來，了解如何找到一個字串的Suffix Array之後，最重要的就是他能用在哪裡了</p>
<h3 id="一、得知一個字串是否為這個字串的子字串-SubString"><a href="#一、得知一個字串是否為這個字串的子字串-SubString" class="headerlink" title="一、得知一個字串是否為這個字串的子字串(SubString)"></a>一、得知一個字串是否為這個字串的子字串(SubString)</h3><p><a href="https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/A">Codeforces 題目連結</a></p>
<p>如何做到這件事情呢 <br><br>首先我們要知道，一個字串的子字串(SubString)一定是一個字串後綴(Suffix)的前綴(Prefix)<br><br>聽起來很難懂 不過來舉例 同樣是aabbaa這個字串 我們要找bb這個子字串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbaa </span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">5</span> a</span><br><span class="line"><span class="number">4</span> aa</span><br><span class="line"><span class="number">0</span> aabbaa</span><br><span class="line"><span class="number">1</span> abbaa</span><br><span class="line"><span class="number">3</span> baa</span><br><span class="line"><span class="number">2</span> *bb*aa</span><br></pre></td></tr></table></figure>
<p>我們可以看到，在bbaa這個子字串的前綴出現了bb這個子字串</p>
<p>除了知道字串是否為這個字串的子字串 我們也可以知道他出現的位置在 $index = 2$ 的位置<br><br><br>那如何去尋找這個子字串呢 我們可以利用「二分搜」來找到出現他的位置</p>
<p>由於Suffix Array已經將字串排序好了 所以二分搜可以直接使用</p>
<p>時間複雜度: $O(nlogn)$</p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由於程式碼太長 這裡省略求Suffix Array</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fastio</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(s.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">	get_suffix(s,ans); <span class="comment">//求Suffix Array</span></span><br><span class="line">	s+=<span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">string</span> q;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">			<span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(s.substr(ans[mid],q.size()) &lt; q)&#123;</span><br><span class="line">				l = mid+<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.substr(ans[mid],q.size()) &gt; q)&#123;</span><br><span class="line">				r = mid<span class="number">-1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">				<span class="keyword">goto</span> stop;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s.substr(ans[l],q.size())==q)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">		stop:;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、子字串-Substring-在字串中出現了幾次-Occurence"><a href="#二、子字串-Substring-在字串中出現了幾次-Occurence" class="headerlink" title="二、子字串(Substring)在字串中出現了幾次(Occurence)"></a>二、子字串(Substring)在字串中出現了幾次(Occurence)</h3><p><a href="https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/B">Codeforces 題目連結</a></p>
<p>總之這個跟剛剛的概念是一樣的 只是二分搜時稍微改變一下寫法 <br><br>這裡就不附程式碼了 <br><br>複雜度依舊為 $O(nlogn)$</p>
<h3 id="三、最長共同前綴-Longest-Common-Prefix（LCP-Array"><a href="#三、最長共同前綴-Longest-Common-Prefix（LCP-Array" class="headerlink" title="三、最長共同前綴 Longest Common Prefix（LCP Array)"></a>三、最長共同前綴 Longest Common Prefix（LCP Array)</h3><p>接下來的用途需要這個才有辦法繼續講<br><br>是一個非常重要的一個東西 <br></p>
<p>首先，我們有了 Suffix Array 這個陣列<br>我們去找 Suffix Array 的 LCP 並弄成陣列 我們稱其為 LCP Array</p>
<p>範例：（一樣拿前面的aabbaa來做示範)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbaa</span><br><span class="line"><span class="number">6</span> </span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;&quot;</span> 長度:<span class="number">0</span></span><br><span class="line"><span class="number">5</span> a</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;a&quot;</span> 長度:<span class="number">1</span></span><br><span class="line"><span class="number">4</span> aa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;aa&quot;</span> 長度:<span class="number">2</span></span><br><span class="line"><span class="number">0</span> aabbaa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;a&quot;</span> 長度:<span class="number">1</span></span><br><span class="line"><span class="number">1</span> abbaa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;&quot;</span> 長度:<span class="number">0</span></span><br><span class="line"><span class="number">3</span> baa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;b&quot;</span> 長度:<span class="number">1</span></span><br><span class="line"><span class="number">2</span> bbaa</span><br></pre></td></tr></table></figure><br>因此 這個字串的 LCP Array 為 $\text{0 1 2 1 0 1}$</p>
<p>而如果我們是希望能求第 $i$ 個前綴與第 $j$ 個前綴的LCP呢？<br></p>
<p>那麼 $LCP(i,j)$則為 $min(LCP(a[i],a[i]+1),LCP(a[i]+1,a[i]+2),…)$<br>（Suffix Array 用 $a[]$ 來表示）<br><br>我們可以利用「線段樹(Segment Tree)」或「稀疏表(Sparse Table)」來求得RMQ <br></p>
<p>而這裡的重點是：我們要如何得到 LCP Array 呢？<br>同樣以 aabbaa 這個陣列來舉例<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbaa</span><br><span class="line"><span class="number">6</span> </span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;&quot;</span> 長度:<span class="number">0</span></span><br><span class="line"><span class="number">5</span> a</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;a&quot;</span> 長度:<span class="number">1</span></span><br><span class="line"><span class="number">4</span> aa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;aa&quot;</span> 長度:<span class="number">2</span></span><br><span class="line"><span class="number">0</span> aabbaa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;a&quot;</span> 長度:<span class="number">1</span></span><br><span class="line"><span class="number">1</span> abbaa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;&quot;</span> 長度:<span class="number">0</span></span><br><span class="line"><span class="number">3</span> baa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;b&quot;</span> 長度:<span class="number">1</span></span><br><span class="line"><span class="number">2</span> bbaa</span><br></pre></td></tr></table></figure><br>先找 $0$ 與其 Suffix Array的前一個位置 $4$ 的 LCP <br><br>我們可以知道其值為 $2$ <br><br>知道這個 $2$ 值之後 我們可以知道 當要掃 $1$ 和 $5$ 的 LCP 時 <br><br>他們的第一個字元一定相等($2-1$) 因此 我們只需要掃 $1$ 以後的字元去得到LCP <br><br>以此類推 我們將可以得到LCP的答案</p>
<p>經過分析之後 我們可以知道有 Suffix Array 後要求 LCP Array 所需的時間複雜度為 $O(n)$ <br><br>由於原本求 Suffix Array 時的時間複雜度為 $O(nlogn)$ <br><br>因此總共時間複雜度為 $O(nlogn)$</p>
<p><a href="https://codeforces.com/edu/course/2/lesson/2/4/practice/contest/269119/problem/A">Codeforces 題目連結</a></p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只需要在求完Suffix Array之後順便求LCP就好了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_suffix</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;lcp)</span></span>&#123;</span><br><span class="line">	s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rank</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="comment">//k = 0</span></span><br><span class="line">	iota(pos.begin(),pos.end(),<span class="number">0</span>);</span><br><span class="line">	sort(pos.begin(),pos.end(),[&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> s[a] &lt; s[b]; &#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)&#123; </span><br><span class="line">			rank[pos[i]] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			rank[pos[i]] = rank[pos[i<span class="number">-1</span>]] + (s[pos[i]]!=s[pos[i<span class="number">-1</span>]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//k &gt; 0</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">new_rank</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;(<span class="number">1</span>&lt;&lt;k) &lt;= n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">			pos[i] = (pos[i] - (<span class="number">1</span>&lt;&lt;k)%n + n ) % n;</span><br><span class="line">		count_sort(pos,rank);</span><br><span class="line">		new_rank[pos[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">			<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prev = &#123;rank[pos[i<span class="number">-1</span>]], rank[(pos[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;k))%n]&#125;;</span><br><span class="line">			<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; now = &#123;rank[pos[i]], rank[(pos[i]+(<span class="number">1</span>&lt;&lt;k))%n]&#125;;</span><br><span class="line">			new_rank[pos[i]] = new_rank[pos[i<span class="number">-1</span>]] + (prev!=now);</span><br><span class="line">		&#125;</span><br><span class="line">		rank = new_rank;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求LCP Array</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> pi = rank[i];</span><br><span class="line">		<span class="keyword">int</span> j = pos[pi<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k]==s[j+k]) k++;</span><br><span class="line">		lcp[pi] = k;</span><br><span class="line">		k = max(<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="四、一個陣列中共有幾個子字串-Substring"><a href="#四、一個陣列中共有幾個子字串-Substring" class="headerlink" title="四、一個陣列中共有幾個子字串(Substring)"></a>四、一個陣列中共有幾個子字串(Substring)</h3><p><a href="https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/A">Codeforces 題目連結</a></p>
<p>如何求一個字串總共有幾個子字串呢 我們可以利用剛剛求得的LCP Array來幫助求解 <br><br>我們可以想到 一個字串的後綴(Suffix)長度 代表有幾個前綴(Prefix) <br><br>扣掉LCP(重複算的Prefix) 則為我們要的答案<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbaa</span><br><span class="line"><span class="number">6</span> </span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;&quot;</span> 長度:<span class="number">0</span> =&gt;　子字串數量：(<span class="number">6</span><span class="number">-5</span>)<span class="number">-0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">5</span> a</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;a&quot;</span> 長度:<span class="number">1</span> =&gt; 子字串數量: (<span class="number">6</span><span class="number">-4</span>)<span class="number">-1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">4</span> aa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;aa&quot;</span> 長度:<span class="number">2</span> =&gt; 子字串數量: (<span class="number">6</span><span class="number">-0</span>)<span class="number">-2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">0</span> aabbaa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;a&quot;</span> 長度:<span class="number">1</span> =&gt; 子字串數量: (<span class="number">6</span><span class="number">-1</span>)<span class="number">-1</span> = <span class="number">4</span></span><br><span class="line"><span class="number">1</span> abbaa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;&quot;</span> 長度:<span class="number">0</span> =&gt; 子字串數量: (<span class="number">6</span><span class="number">-3</span>)<span class="number">-0</span> = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> baa</span><br><span class="line">    =&gt;共同前綴為<span class="string">&quot;b&quot;</span> 長度:<span class="number">1</span> =&gt; 子字串數量: (<span class="number">6</span><span class="number">-2</span>)<span class="number">-1</span> = <span class="number">3</span></span><br><span class="line"><span class="number">2</span> bbaa                                 Total: <span class="number">16</span></span><br></pre></td></tr></table></figure><br>經由上面的操作 我們能在有LCP Array後 在 $O(n)$ 時間求出子字串數量 <br></p>
<p>程式碼<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一樣由於程式碼太長 僅提供main函數裡的程式</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">vector&lt;int&gt; ans(s.size()+1), lcp(s.size()+1,0);</span><br><span class="line">get_suffix(s,ans,lcp);</span><br><span class="line">s += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> n = s.size();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">    res += (<span class="number">6</span>-ans[i])-lcp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="五、最長共同子字串-Longest-Common-Substring"><a href="#五、最長共同子字串-Longest-Common-Substring" class="headerlink" title="五、最長共同子字串 Longest Common Substring"></a>五、最長共同子字串 Longest Common Substring</h3><p>這題應該是大部分人在學到 dp 時都會解到的經典題目 <br><br>而使用 dp 解這題時 一般的複雜度會是 $O(n^2)$ <br><br>而當我們有了 Suffix Array 與 LCP Array 之後 <br><br>我們就可以用 $O(nlogn)$ 的複雜度求得最長共同子字串了<br><br><br>如何用 Suffix Array 找到最長共同子字串呢 <br><br>我們可以先將兩個字串接在一起 然後去找他們的 Suffix Array 與 LCP</p>
<p>範例:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aabbcc<span class="meta">#dabc <span class="comment">//為了方便解釋 我們在字串中間加入一個# (#的字典序比字母小）</span></span></span><br><span class="line"><span class="number">6</span> <span class="meta">#dabc$</span></span><br><span class="line"><span class="number">11</span> $</span><br><span class="line">-------------------------------- 我們可以無視上面那兩個suffix</span><br><span class="line"><span class="number">0</span> aabbcc<span class="meta">#dabc$</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;a&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">1</span> abbcc#dabc$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;ab&quot;</span> 長度:<span class="number">2</span></span><br><span class="line"><span class="number">8</span> abc$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;&quot;</span>   長度:<span class="number">0</span></span><br><span class="line"><span class="number">2</span> bbcc#dabc$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;b&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">9</span> bc$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;bc&quot;</span> 長度:<span class="number">2</span></span><br><span class="line"><span class="number">3</span> bcc#dabc$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;&quot;</span>   長度:<span class="number">0</span></span><br><span class="line"><span class="number">5</span> c#dabc$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;c&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">10</span> c$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;c&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">4</span> cc#dabc$</span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;&quot;</span>   長度:<span class="number">0</span></span><br><span class="line"><span class="number">7</span> dabc$</span><br></pre></td></tr></table></figure></p>
<p>從這些東西 我們可以知道的是如果後綴是從 $index=6$ 以後開始的 <br><br>那他的前綴會是第二個字串的子字串（亦即沒出現#符號的）<br>我們可以給這些字串做上 $1$ 和 $2$ 的標記<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> aabbcc<span class="meta">#dabc$  編號:1</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;a&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">1</span> abbcc#dabc$   編號:<span class="number">1</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;ab&quot;</span> 長度:<span class="number">2</span></span><br><span class="line"><span class="number">8</span> abc$          編號:<span class="number">2</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;&quot;</span>   長度:<span class="number">0</span></span><br><span class="line"><span class="number">2</span> bbcc#dabc$    編號:<span class="number">1</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;b&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">9</span> bc$           編號:<span class="number">2</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;bc&quot;</span> 長度:<span class="number">2</span></span><br><span class="line"><span class="number">3</span> bcc#dabc$     編號:<span class="number">1</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;&quot;</span>   長度:<span class="number">0</span></span><br><span class="line"><span class="number">5</span> c#dabc$       編號:<span class="number">1</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;c&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">10</span> c$           編號:<span class="number">2</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;c&quot;</span>  長度:<span class="number">1</span></span><br><span class="line"><span class="number">4</span> cc#dabc$      編號:<span class="number">1</span></span><br><span class="line">                =&gt;共同前綴為<span class="string">&quot;&quot;</span>   長度:<span class="number">0</span></span><br><span class="line"><span class="number">7</span> dabc$         編號:<span class="number">2</span></span><br></pre></td></tr></table></figure><br>而要求得兩字串的最長子字串 就會是所有編號為 $1$ 和 $2$ 字串 LCP 的最大值</p>
<p>複雜度:$O(nlogn)$</p>
<p>程式碼：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一樣由於程式碼太長 僅提供main函數裡的程式</span></span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line"><span class="keyword">int</span> tmp = s1.size();</span><br><span class="line">s1 += <span class="string">&quot;#&quot;</span> + s2;</span><br><span class="line">vector&lt;int&gt; ans(s1.size()+1), lcp(s1.size()+1,0);</span><br><span class="line">get_suffix(s1,ans,lcp);</span><br><span class="line">s1 += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> n = s1.size();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((ans[i]&gt;=tmp&amp;&amp;ans[i<span class="number">-1</span>]&lt;tmp)||(ans[i]&lt;tmp&amp;&amp;ans[i<span class="number">-1</span>]&gt;tmp))&#123;</span><br><span class="line">        <span class="keyword">if</span>(lcp[i] &gt; res) res = max(lcp[i],res), str = s1.substr(ans[i],res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="更多應用代補"><a href="#更多應用代補" class="headerlink" title="更多應用代補"></a>更多應用代補</h3><p>代補</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Suffix Array 真的是一個很神奇的東西 可以把一些平常認為需要 $O(n^2)$ 的題目 <br><br>利用 Suffix Array 與 LCP Array 在 $O(nlogn)解出來 <br><br>這篇文章今後在解到更多Suffix Array的題目之後 會再更新 </p>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>教學</tag>
        <tag>String</tag>
        <tag>字串</tag>
        <tag>Suffix Array</tag>
        <tag>LCP Array</tag>
      </tags>
  </entry>
</search>
